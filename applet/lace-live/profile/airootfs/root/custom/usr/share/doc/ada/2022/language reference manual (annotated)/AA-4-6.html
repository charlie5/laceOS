<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Type Conversions</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    SPAN.insert5 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete5 {text-decoration: line-through; color: rgb(0,102,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.8em; margin-bottom: 0.6em}
    DIV.Indented1 {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-bottom: 0.6em}
    DIV.WideAbove {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.8em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 4.3em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.8em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.Indented2NestedBulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Indented2NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.Indented3NestedBulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Indented3NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,51,153)"><B>Annotated</B></SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)"><B>&nbsp;Ada Reference Manual</B> (Ada 202x Draft 33)</SPAN> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-10.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-7.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>4.6 Type Conversions</H1>
<div class="paranum"><a name="p1">1/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0299-1.TXT">AI05-0299-1</A></I>} 
[Explicit type conversions, both value conversions and view conversions, 
are allowed between closely related types as defined below. This subclause 
also defines rules for value and view conversions to a particular subtype 
of a type, both explicit ones and those implicit in other constructs. 
<A NAME="I3502"></A><A NAME="I3503"></A><A NAME="I3504"></A><A NAME="I3505"></A>]<A NAME="I3506"></A><A NAME="I3507"></A></div>

<H4 Class="centered">Syntax</H4>
<div class="paranum"><a name="p2">2</a></div>
<div class="Indented1"><SPAN Class="swiss">type_conversion</SPAN><A NAME="I3508"></A><A NAME="S0162"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I3509"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>(<A NAME="I3510"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0132">expression</A></SPAN>)<BR>
&nbsp;&nbsp;|&nbsp;<A NAME="I3511"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>(<A NAME="I3512"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)</div>
<div class="paranum"><a name="p3">3</a></div>
<div class="Normal"><A NAME="I3513"></A>The <I>target subtype</I> of 
a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is the subtype denoted by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>. 
<A NAME="I3514"></A>The <I>operand</I> of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0132">expression</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> within 
the parentheses; <A NAME="I3515"></A>its type is the <I>operand type</I>.</div>
<div class="paranum"><a name="p4">4/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0299-1.TXT">AI05-0299-1</A></I>} 
<A NAME="I3516"></A>One type is <I>convertible</I> to a second type if 
a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
with the first type as operand type and the second type as target type 
is legal according to the rules of this subclause. Two types are convertible 
if each is convertible to the other.&nbsp;</div>
<div class="paranum"><a name="p4.a">4.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Note that &ldquo;convertible&rdquo; 
is defined in terms of legality of the conversion. Whether the conversion 
would raise an exception at run time is irrelevant to this definition. 
</div>
<div class="paranum"><a name="p5">5/5</a></div>
<div class="Normal">{<I><A HREF="defect1.html#8652/0017">8652/0017</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00184.TXT">AI95-00184-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00330.TXT">AI95-00330-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0392-1.TXT">AI12-0392-1</A></I>} 
<A NAME="I3517"></A><A NAME="I3518"></A>A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
<span class="delete5">whose operand is the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of an object&nbsp;</span>is called a <I>view conversion</I> if both its target 
type and operand type are tagged, or if it appears in a call as an actual 
parameter of mode <B>out</B> or <B>in out</B>; <A NAME="I3519"></A><A NAME="I3520"></A>other 
<SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN>s 
are called <I>value conversions</I>. <A NAME="I3521"></A></div>
<div class="paranum"><a name="p5.a">5.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A view conversion to a 
tagged type can appear in any context that requires an object <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, 
including in an object renaming, the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0098">selected_component</A></SPAN>, 
and if the operand is a variable, on the left side of an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0173">assignment_statement</A></SPAN>. 
View conversions to other types only occur as actual parameters. Allowing 
view conversions of untagged types in all contexts seemed to incur an 
undue implementation burden.</div>
<div class="paranum"><a name="p5.b">5.b/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00330.TXT">AI95-00330-01</A></I>} 
A type conversion appearing as an <B>in out</B> parameter in a generic 
instantiation is not a view conversion; the second part of the rule only 
applies to subprogram calls, not instantiations.&nbsp;</div>

<H4 Class="centered">Name Resolution Rules</H4>
<div class="paranum"><a name="p6">6</a></div>
<div class="Normal"><A NAME="I3522"></A>The operand of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is expected to be of any type.&nbsp;</div>
<div class="paranum"><a name="p6.a">6.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>This replaces the &ldquo;must 
be determinable&rdquo; wording of Ada 83. This is equivalent to (but 
hopefully more intuitive than) saying that the operand of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is a &ldquo;complete context&rdquo;.&nbsp;</div>
<div class="paranum"><a name="p7">7</a></div>
<div class="Normal">The operand of a view conversion is interpreted only 
as a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>; 
the operand of a value conversion is interpreted as an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0132">expression</A></SPAN>. 
</div>
<div class="paranum"><a name="p7.a">7.a/5</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
This formally resolves the syntactic ambiguity between the two forms 
of <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN><span class="insert4">. 
This matters&nbsp;</span><span class="insert5">because</span><span class="insert4"></span><span class="insert4"><span class="delete5">&nbsp;as</span></span><span class="insert4">&nbsp;an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0132">expression</A></SPAN> 
that is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is evaluated and represents a value while a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
by itself can be an object; we want a view conversion to be an object</span><span class="delete4">, 
not that it really matters</span>.&nbsp;</div>
<div class="paranum"><a name="p7.b">7.b/4</a></div>
<div class="Annotations"><span class="insert4"><B>Ramification:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
<span class="insert4">This wording uses &quot;interpreted as&quot; rather 
than &quot;shall be&quot; so that this rule is not used to resolve overloading; 
it is solely about evaluation as described above.</span>&nbsp;</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p8">8/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
In a view conversion for an untagged type, the target type shall be convertible 
(back) to the operand type.&nbsp;</div>
<div class="paranum"><a name="p8.a">8.a/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Untagged view conversions appear 
only as [<B>in</B>] <B>out</B> parameters. Hence, the reverse conversion 
must be legal as well. The forward conversion must be legal even for 
an <B>out</B> parameter, because (for example) actual parameters of an 
access type are always copied in anyway.&nbsp;</div>
<div class="Normal"><SPAN STYLE="font-size: 80%"><I>Paragraphs 9 through 
20 were reorganized and moved below.</I></SPAN>&nbsp;</div>
<div class="paranum"><a name="p8.b">8.b/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The entire Legality Rules section has been reorganized to eliminate an 
unintentional incompatibility with Ada 83. In rare cases, a type conversion 
between two types related by derivation is not allowed by Ada 95, while 
it is allowed in Ada 83. The reorganization fixes this. Much of the wording 
of the legality section is unchanged, but it is reordered and reformatted. 
Because of the limitations of our tools, we had to delete and replace 
nearly the entire section. The text of Ada 95 paragraphs 8 through 12, 
14, 15, 17, 19, 20, and 24 are unchanged (just moved); these are now 
24.1 through 24.5, 24.12, 24.13, 24.17, 24.19, 24.20, and 8.&nbsp;</div>
<div class="paranum"><a name="p21">21/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0115-1.TXT">AI05-0115-1</A></I>} 
<A NAME="I3523"></A><A NAME="I3524"></A>If there is a type (other than 
a root numeric type) that is an ancestor of both the target type and 
the operand type, or both types are class-wide types, then at least one 
of the following rules shall apply:&nbsp;</div>
<div class="paranum"><a name="p21.1">21.1/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<A NAME="I3525"></A><A NAME="I3526"></A>The target type shall be untagged; 
or</div>
<div class="paranum"><a name="p22">22</a></div>
<div class="Bulleted">The operand type shall be covered by or descended 
from the target type; or&nbsp;</div>
<div class="paranum"><a name="p22.a">22.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This is a conversion toward 
the root, which is always safe.&nbsp;</div>
<div class="paranum"><a name="p23">23/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The operand type shall be a class-wide type that covers the target type; 
or&nbsp;</div>
<div class="paranum"><a name="p23.a">23.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This is a conversion of 
a class-wide type toward the leaves, which requires a tag check. See 
Dynamic Semantics.</div>
<div class="paranum"><a name="p23.b">23.b/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
These two rules imply that a conversion from an ancestor type to a type 
extension is not permitted, as this would require specifying the values 
for additional components, in general, and changing the tag. An <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN> 
has to be used instead, constructing a new value, rather than converting 
an existing value. However, a conversion from the class-wide type rooted 
at an ancestor type is permitted; such a conversion just verifies that 
the operand's tag is a descendant of the target.&nbsp;</div>
<div class="paranum"><a name="p23.1">23.1/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The operand and target types shall both be class-wide types and the specific 
type associated with at least one of them shall be an interface type. 
</div>
<div class="paranum"><a name="p23.c">23.c/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>We allow converting any 
class-wide type T'Class to or from a class-wide interface type even if 
the specific type T does not have an appropriate interface ancestor, 
because some extension of T might have the needed ancestor. This is similar 
to a conversion of a class-wide type toward the leaves of the tree, and 
we need to be consistent. Of course, there is a runtime check that the 
actual object has the needed interface.&nbsp;</div>
<div class="paranum"><a name="p24">24/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0115-1.TXT">AI05-0115-1</A></I>} 
If there is no type (other than a root numeric type) that is the ancestor 
of both the target type and the operand type, and they are not both class-wide 
types, one of the following rules shall apply:&nbsp;</div>
<div class="paranum"><a name="p24.1">24.1/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<A NAME="I3527"></A><A NAME="I3528"></A>If the target type is a numeric 
type, then the operand type shall be a numeric type.</div>
<div class="paranum"><a name="p24.2">24.2/2</a></div>
<div class="Bulleted" style="margin-bottom: 0.3em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<A NAME="I3529"></A><A NAME="I3530"></A>If the target type is an array 
type, then the operand type shall be an array type. Further:</div>
<div class="paranum"><a name="p24.3">24.3/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The types shall have the same dimensionality;</div>
<div class="paranum"><a name="p24.4">24.4/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Corresponding index types shall be convertible; <A NAME="I3531"></A></div>
<div class="paranum"><a name="p24.5">24.5/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The component subtypes shall statically match; <A NAME="I3532"></A></div>
<div class="paranum"><a name="p24.6">24.6/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00392.TXT">AI95-00392-01</A></I>} 
If the component types are anonymous access types, then the accessibility 
level of the operand type shall not be statically deeper than that of 
the target type; <A NAME="I3533"></A></div>
<div class="paranum"><a name="p24.b">24.b/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>For unrelated array types, the 
component types could have different accessibility, and we had better 
not allow a conversion of a local type into a global type, in case the 
local type points at local objects. We don't need a check for other types 
of components; such components necessarily are for related types, and 
either have the same accessibility or (for access discriminants) cannot 
be changed so the discriminant check will prevent problems.&nbsp;</div>
<div class="paranum"><a name="p24.7">24.7/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00246.TXT">AI95-00246-01</A></I>} 
Neither the target type nor the operand type shall be limited;&nbsp;</div>
<div class="paranum"><a name="p24.c">24.c/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>We cannot allow conversions between 
unrelated limited types, as they may have different representations, 
and (since the types are limited), a copy cannot be made to reconcile 
the representations.&nbsp;</div>
<div class="paranum"><a name="p24.8">24.8/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
If the target type of a view conversion has aliased components, then 
so shall the operand type; and&nbsp;</div>
<div class="paranum"><a name="p24.d">24.d/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
We cannot allow a view conversion from an object with unaliased components 
to an object with aliased components, because that would effectively 
allow pointers to unaliased components. This rule was missing from Ada 
95.&nbsp;</div>
<div class="paranum"><a name="p24.9">24.9/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00246.TXT">AI95-00246-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The operand type of a view conversion shall not have a tagged, private, 
or volatile subcomponent.&nbsp;</div>
<div class="paranum"><a name="p24.e">24.e/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00246.TXT">AI95-00246-01</A></I>} 
We cannot allow view conversions between unrelated might-be-by-reference 
types, as they may have different representations, and a copy cannot 
be made to reconcile the representations.&nbsp;</div>
<div class="paranum"><a name="p24.f">24.f/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>These rules only apply 
to unrelated array conversions; different (weaker) rules apply to conversions 
between related types.&nbsp;</div>
<div class="paranum"><a name="p24.10">24.10/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
If the target type is <I>universal_access</I>, then the operand type 
shall be an access type.</div>
<div class="paranum"><a name="p24.g">24.g/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>Such a conversion cannot 
be written explicitly, of course, but it can be implicit (see below). 
</div>
<div class="paranum"><a name="p24.11">24.11/2</a></div>
<div class="Bulleted" style="margin-bottom: 0.3em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<A NAME="I3534"></A><A NAME="I3535"></A>If the target type is a general 
access-to-object type, then the operand type shall be <I>universal_access</I> 
or an access-to-object type. Further, if the operand type is not <I>universal_access</I>:</div>
<div class="paranum"><a name="p24.h">24.h/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The Legality Rules and Dynamic 
Semantics are worded so that a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
T(X) (where T is an access type) is (almost) equivalent to the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
X.<B>all</B>'Access, where the result is of type T. The only difference 
is that the <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
accepts a null value, whereas the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
would raise Constraint_Error.&nbsp;</div>
<div class="paranum"><a name="p24.12">24.12/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
If the target type is an access-to-variable type, then the operand type 
shall be an access-to-variable type;&nbsp;</div>
<div class="paranum"><a name="p24.i">24.i/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>If the target type is an 
access-to-constant type, then the operand type can be access-to-constant 
or access-to-variable.&nbsp;</div>
<div class="paranum"><a name="p24.13">24.13/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
If the target designated type is tagged, then the operand designated 
type shall be convertible to the target designated type; <A NAME="I3536"></A></div>
<div class="paranum"><a name="p24.14">24.14/2</a></div>
<div class="Indented2NestedBulleted" style="margin-bottom: 0.3em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
If the target designated type is not tagged, then the designated types 
shall be the same, and either:</div>
<div class="paranum"><a name="p24.15">24.15/2</a></div>
<div class="Indented3NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
the designated subtypes shall statically match; or<A NAME="I3537"></A></div>
<div class="paranum"><a name="p24.16">24.16/2</a></div>
<div class="Indented3NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00384.TXT">AI95-00384-01</A></I>} 
the designated type shall be discriminated in its full view and unconstrained 
in any partial view, and one of the designated subtypes shall be unconstrained;</div>
<div class="paranum"><a name="p24.j">24.j/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
This does not require that types have a partial view in order to allow 
the conversion, simply that any partial view that does exist is unconstrained.</div>
<div class="paranum"><a name="p24.k">24.k/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00384.TXT">AI95-00384-01</A></I>} 
This allows conversions both ways (either subtype can be unconstrained); 
while Ada 95 only allowed the conversion if the target subtype is unconstrained. 
We generally want type conversions to be symmetric; which type is the 
target shouldn't matter for legality.&nbsp;</div>
<div class="paranum"><a name="p24.l">24.l/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
If the visible partial view is constrained, we do not allow conversion 
between unconstrained and constrained subtypes. This means that whether 
the full type had discriminants is not visible to clients of the partial 
view.&nbsp;</div>
<div class="paranum"><a name="p24.l.1">24.l.1/5</a></div>
<div class="Annotations"><span class="insert4"><B>Discussion:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0095-1.TXT">AI12-0095-1</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
<span class="insert4">We assume the worst in a generic body</span><span class="insert5">&nbsp;about</span><span class="insert4">&nbsp;whether or not a formal subtype has 
a constrained partial view; specifically, in a generic body a discriminated 
subtype is considered to have a constrained partial view if it is a descendant 
of an untagged generic formal private or derived type (see <A HREF="AA-12-5-1.html">12.5.1</A> 
for the formal definition of this rule).</span>&nbsp;</div>
<div class="paranum"><a name="p24.m">24.m/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>These rules are designed to ensure 
that aliased array objects only <I>need</I> &quot;dope&quot; if their 
nominal subtype is unconstrained, but they can always <I>have</I> dope 
if required by the run-time model (since no sliding is permitted as part 
of access type conversion). By contrast, aliased discriminated objects 
will always <I>need</I> their discriminants stored with them, even if 
nominally constrained. (Here, we are assuming an implementation that 
represents an access value as a single pointer.)&nbsp;</div>
<div class="paranum"><a name="p24.17">24.17/4</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0148-1.TXT">AI05-0148-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0248-1.TXT">AI05-0248-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<A NAME="I3538"></A>The accessibility level of the operand type shall 
not be statically deeper than that of the target type, unless the target 
type is an anonymous access type of a stand-alone object. If the target 
type is that of such a stand-alone object, the accessibility level of 
the operand type shall not be statically deeper than that of the declaration 
of the stand-alone object.<span class="delete4">&nbsp;<A NAME="I3539"></A>In 
addition to the places where Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>), 
this rule applies also in the private part of an instance of a generic 
unit.</span>&nbsp;</div>
<div class="paranum"><a name="p24.n">24.n/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0148-1.TXT">AI05-0148-1</A></I>} 
The access parameter case is handled by a run-time check. runtime checks 
are also done in instance bodies, and for stand-alone objects of anonymous 
access types.&nbsp;</div>
<div class="paranum"><a name="p24.n.1">24.n.1/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>We prohibit storing accesses 
to objects deeper than a stand-alone object of an anonymous access-to-object 
(even while we allow storing all other accesses) in order to prevent 
dangling accesses.&nbsp;</div>
<div class="paranum"><a name="p24.18">24.18/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<A NAME="I3540"></A><A NAME="I3541"></A>If the target type is a pool-specific 
access-to-object type, then the operand type shall be <I>universal_access</I>. 
</div>
<div class="paranum"><a name="p24.o">24.o/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>This allows <B>null</B> to be 
converted to pool-specific types. Without it, <B>null</B> could be converted 
to general access types but not pool-specific ones, which would be too 
inconsistent. Remember that these rules only apply to unrelated types, 
so we don't have to talk about conversions to derived or other related 
types.&nbsp;</div>
<div class="paranum"><a name="p24.19">24.19/2</a></div>
<div class="Bulleted" style="margin-bottom: 0.3em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<A NAME="I3542"></A><A NAME="I3543"></A>If the target type is an access-to-subprogram 
type, then the operand type shall be <I>universal_access</I> or an access-to-subprogram 
type. Further, if the operand type is not <I>universal_access</I>:</div>
<div class="paranum"><a name="p24.20">24.20/3</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0239-1.TXT">AI05-0239-1</A></I>} 
The designated profiles shall be subtype conformant. <A NAME="I3544"></A></div>
<div class="paranum"><a name="p24.21">24.21/4</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<A NAME="I3545"></A>The accessibility level of the operand type shall 
not be statically deeper than that of the target type.<span class="delete4">&nbsp;<A NAME="I3546"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), this rule applies also in 
the private part of an instance of a generic unit.</span> If the operand 
type is declared within a generic body, the target type shall be declared 
within the generic body.</div>
<div class="paranum"><a name="p24.p">24.p/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>The reason it is illegal to convert 
from an access-to-subprogram type declared in a generic body to one declared 
outside that body is that in an implementation that shares generic bodies, 
subprograms declared inside the generic need to have a different calling 
convention &mdash; they need an extra parameter pointing to the data 
declared in the current instance. For subprograms declared in the spec, 
that's OK, because the compiler can know about them at compile time of 
the instantiation.&nbsp;</div>
<div class="paranum"><a name="p24.22">24.22/5</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0380-1.TXT">AI12-0380-1</A></I>} 
<span class="insert5">If the target type has a Global aspect other than 
<B>in out all</B> or Unspecified, then each mode of the Global aspect 
of the operand type shall identify a subset of the variables identified 
by the corresponding mode of the target type Global aspect, or by the 
<B>in out</B> mode of the target type Global aspect.</span></div>
<div class="paranum"><a name="p24.23">24.23/5</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0064-2.TXT">AI12-0064-2</A></I>} 
<span class="insert5">If the target type is nonblocking, the operand 
type shall be nonblocking.</span>&nbsp;</div>
<div class="paranum"><a name="p24.24">24.24/5</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<span class="insert4"><A NAME="I3547"></A>In addition to the places where 
Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>), 
these rules apply also in the private part of an instance of a generic 
unit.</span>&nbsp;</div>
<div class="paranum"><a name="p24.q">24.q/5</a></div>
<div class="Annotations"><span class="insert4"><B>Discussion:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
<span class="insert4">This applies to <I>all</I> of the Legality Rules 
in this section. It won't matter for the majority of these rules, but 
in any case that it does, we want to apply the same&nbsp;</span><span class="insert5">rules</span><span class="insert4"></span><span class="insert4"><span class="delete5">&nbsp;recheck</span></span><span class="insert4">&nbsp;in the private part. (Ada got the default wrong for these, as there is 
only one known case where we don't want to recheck in the private part, 
see derivations without record extensions in <A HREF="AA-3-4.html">3.4</A>.)</span> 
</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p25">25</a></div>
<div class="Normal">A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
that is a value conversion denotes the value that is the result of converting 
the value of the operand to the target subtype.</div>
<div class="paranum"><a name="p26">26/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0264-1.TXT">AI05-0264-1</A></I>} 
A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
that is a view conversion denotes a view of the object denoted by the 
operand. This view is a variable of the target type if the operand denotes 
a variable; otherwise, it is a constant of the target type.</div>
<div class="paranum"><a name="p27">27</a></div>
<div class="Normal"><A NAME="I3548"></A>The nominal subtype of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is its target subtype.&nbsp;</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p28">28</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I3549"></A><A NAME="I3550"></A><A NAME="I3551"></A>For 
the evaluation of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
that is a value conversion, the operand is evaluated, and then the value 
of the operand is <I>converted</I> to a <I>corresponding</I> value of 
the target type, if any. <A NAME="I3552"></A><A NAME="I3553"></A><A NAME="I3554"></A>If 
there is no value of the target type that corresponds to the operand 
value, Constraint_Error is raised[; this can only happen on conversion 
to a modular type, and only when the operand value is outside the base 
range of the modular type.] Additional rules follow:&nbsp;</div>
<div class="paranum"><a name="p29">29</a></div>
<div class="Bulleted"><A NAME="I3555"></A><A NAME="I3556"></A>Numeric 
Type Conversion&nbsp;</div>
<div class="paranum"><a name="p30">30</a></div>
<div class="Indented2NestedBulleted">If the target and the operand types 
are both integer types, then the result is the value of the target type 
that corresponds to the same mathematical integer as the operand.</div>
<div class="paranum"><a name="p31">31</a></div>
<div class="Indented2NestedBulleted">If the target type is a decimal 
fixed point type, then the result is truncated (toward 0) if the value 
of the operand is not a multiple of the <I>small</I> of the target type.</div>
<div class="paranum"><a name="p32">32</a></div>
<div class="Indented2NestedBulleted"><A NAME="I3557"></A>If the target 
type is some other real type, then the result is within the accuracy 
of the target type (see <A HREF="AA-G-2.html">G.2</A>, &ldquo;<A HREF="AA-G-2.html">Numeric 
Performance Requirements</A>&rdquo;, for implementations that support 
the Numerics Annex).&nbsp;</div>
<div class="paranum"><a name="p32.a">32.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>An integer type might have 
more bits of precision than a real type, so on conversion (of a large 
integer), some precision might be lost.&nbsp;</div>
<div class="paranum"><a name="p33">33</a></div>
<div class="Indented2NestedBulleted">If the target type is an integer 
type and the operand type is real, the result is rounded to the nearest 
integer (away from zero if exactly halfway between two integers).&nbsp;</div>
<div class="paranum"><a name="p33.a">33.a/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00267.TXT">AI95-00267-01</A></I>} 
This was implementation defined in Ada 83. There seems no reason to preserve 
the nonportability in Ada 95. Round-away-from-zero is the conventional 
definition of rounding, and standard Fortran and COBOL both specify rounding 
away from zero, so for interoperability, it seems important to pick this. 
This is also the most easily &ldquo;undone&rdquo; by hand. Round-to-nearest-even 
is an alternative, but that is quite complicated if not supported by 
the hardware. In any case, this operation is not usually part of an inner 
loop, so predictability and portability are judged most important. A 
floating point attribute function Unbiased_Rounding is provided (see 
<A HREF="AA-A-5-3.html">A.5.3</A>) for those applications that require 
round-to-nearest-even, and a floating point attribute function Machine_Rounding 
(also see <A HREF="AA-A-5-3.html">A.5.3</A>) is provided for those applications 
that require the highest possible performance. &ldquo;Deterministic&rdquo; 
rounding is required for static conversions to integer as well. See <A HREF="AA-4-9.html">4.9</A>. 
</div>
<div class="paranum"><a name="p34">34</a></div>
<div class="Bulleted"><A NAME="I3558"></A><A NAME="I3559"></A>Enumeration 
Type Conversion&nbsp;</div>
<div class="paranum"><a name="p35">35</a></div>
<div class="Indented2NestedBulleted">The result is the value of the target 
type with the same position number as that of the operand value.&nbsp;</div>
<div class="paranum"><a name="p36">36</a></div>
<div class="Bulleted"><A NAME="I3560"></A><A NAME="I3561"></A>Array Type 
Conversion&nbsp;</div>
<div class="paranum"><a name="p37">37</a></div>
<div class="Indented2NestedBulleted"><A NAME="I3562"></A><A NAME="I3563"></A>If 
the target subtype is a constrained array subtype, then a check is made 
that the length of each dimension of the value of the operand equals 
the length of the corresponding dimension of the target subtype. The 
bounds of the result are those of the target subtype.</div>
<div class="paranum"><a name="p38">38</a></div>
<div class="Indented2NestedBulleted"><A NAME="I3564"></A><A NAME="I3565"></A>If 
the target subtype is an unconstrained array subtype, then the bounds 
of the result are obtained by converting each bound of the value of the 
operand to the corresponding index type of the target type. <A NAME="I3566"></A>For 
each nonnull index range, a check is made that the bounds of the range 
belong to the corresponding index subtype.&nbsp;</div>
<div class="paranum"><a name="p38.a">38.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>Only nonnull index ranges 
are checked, per AI83-00313.&nbsp;</div>
<div class="paranum"><a name="p39">39</a></div>
<div class="Indented2NestedBulleted">In either array case, the value 
of each component of the result is that of the matching component of 
the operand value (see <A HREF="AA-4-5-2.html">4.5.2</A>).&nbsp;</div>
<div class="paranum"><a name="p39.a">39.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This applies whether or 
not the component is initialized.&nbsp;</div>
<div class="paranum"><a name="p39.1">39.1/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00392.TXT">AI95-00392-01</A></I>} 
If the component types of the array types are anonymous access types, 
then a check is made that the accessibility level of the operand type 
is not deeper than that of the target type. <A NAME="I3567"></A><A NAME="I3568"></A></div>
<div class="paranum"><a name="p39.b">39.b/5</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
This check is needed for operands that are <span class="delete5">access 
parameters and&nbsp;</span>in instance bodies. Other cases are handled by 
the legality rule given previously.&nbsp;</div>
<div class="paranum"><a name="p40">40</a></div>
<div class="Bulleted"><A NAME="I3569"></A><A NAME="I3570"></A>Composite 
(Non-Array) Type Conversion&nbsp;</div>
<div class="paranum"><a name="p41">41</a></div>
<div class="Indented2NestedBulleted">The value of each nondiscriminant 
component of the result is that of the matching component of the operand 
value.&nbsp;</div>
<div class="paranum"><a name="p41.a">41.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This applies whether or 
not the component is initialized.&nbsp;</div>
<div class="paranum"><a name="p42">42</a></div>
<div class="Indented2NestedBulleted">[The tag of the result is that of 
the operand.] <A NAME="I3571"></A><A NAME="I3572"></A>If the operand 
type is class-wide, a check is made that the tag of the operand identifies 
a (specific) type that is covered by or descended from the target type. 
</div>
<div class="paranum"><a name="p42.a">42.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This check is certain to 
succeed if the operand type is itself covered by or descended from the 
target type.&nbsp;</div>
<div class="paranum"><a name="p42.b">42.b</a></div>
<div class="Annotations"><B>Proof:&nbsp;</B>The fact that a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
preserves the tag is stated officially in <A HREF="AA-3-9.html">3.9</A>, 
&ldquo;<A HREF="AA-3-9.html">Tagged Types and Type Extensions</A>&rdquo; 
</div>
<div class="paranum"><a name="p43">43</a></div>
<div class="Indented2NestedBulleted">For each discriminant of the target 
type that corresponds to a discriminant of the operand type, its value 
is that of the corresponding discriminant of the operand value; <A NAME="I3573"></A><A NAME="I3574"></A>if 
it corresponds to more than one discriminant of the operand type, a check 
is made that all these discriminants are equal in the operand value.</div>
<div class="paranum"><a name="p44">44</a></div>
<div class="Indented2NestedBulleted">For each discriminant of the target 
type that corresponds to a discriminant that is specified by the <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
for some ancestor of the operand type (or if class-wide, some ancestor 
of the specific type identified by the tag of the operand), its value 
in the result is that specified by the <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>. 
</div>
<div class="paranum"><a name="p44.a">44.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>It is a ramification of 
the rules for the discriminants of derived types that each discriminant 
of the result is covered either by this paragraph or the previous one. 
See <A HREF="AA-3-7.html">3.7</A>.&nbsp;</div>
<div class="paranum"><a name="p45">45</a></div>
<div class="Indented2NestedBulleted"><A NAME="I3575"></A><A NAME="I3576"></A>For 
each discriminant of the operand type that corresponds to a discriminant 
that is specified by the <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
for some ancestor of the target type, a check is made that in the operand 
value it equals the value specified for it.</div>
<div class="paranum"><a name="p46">46</a></div>
<div class="Indented2NestedBulleted"><A NAME="I3577"></A><A NAME="I3578"></A>For 
each discriminant of the result, a check is made that its value belongs 
to its subtype.&nbsp;</div>
<div class="paranum"><a name="p47">47</a></div>
<div class="Bulleted"><A NAME="I3579"></A><A NAME="I3580"></A>Access 
Type Conversion&nbsp;</div>
<div class="paranum"><a name="p48">48/3</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0148-1.TXT">AI05-0148-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0248-1.TXT">AI05-0248-1</A></I>} 
For an access-to-object type, a check is made that the accessibility 
level of the operand type is not deeper than that of the target type, 
unless the target type is an anonymous access type of a stand-alone object. 
If the target type is that of such a stand-alone object, a check is made 
that the accessibility level of the operand type is not deeper than that 
of the declaration of the stand-alone object[; then if the check succeeds, 
the accessibility level of the target type becomes that of the operand 
type]. <A NAME="I3581"></A><A NAME="I3582"></A></div>
<div class="paranum"><a name="p48.a">48.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0148-1.TXT">AI05-0148-1</A></I>} 
This check is needed for operands that are access parameters, for stand-alone 
anonymous access objects, and in instance bodies.</div>
<div class="paranum"><a name="p48.b">48.b</a></div>
<div class="Annotations">Note that this check can never fail for the 
implicit conversion to the anonymous type of an access parameter that 
is done when calling a subprogram with an access parameter.&nbsp;</div>
<div class="paranum"><a name="p49">49/2</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
If the operand value is null, the result of the conversion is the null 
value of the target type.&nbsp;</div>
<div class="paranum"><a name="p49.a">49.a/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A conversion to an anonymous 
access type happens implicitly as part of initializing or assigning to 
an anonymous access object.&nbsp;</div>
<div class="paranum"><a name="p50">50</a></div>
<div class="Indented2NestedBulleted">If the operand value is not null, 
then the result designates the same object (or subprogram) as is designated 
by the operand value, but viewed as being of the target designated subtype 
(or profile); any checks associated with evaluating a conversion to the 
target designated subtype are performed.&nbsp;</div>
<div class="paranum"><a name="p50.a">50.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The checks are certain 
to succeed if the target and operand designated subtypes statically match. 
</div>
<div class="paranum"><a name="p51">51/5</a></div>
<div class="Normal" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0071-1.TXT">AI12-0071-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0333-1.TXT">AI12-0333-1</A></I>} 
<span class="insert5"></span><A NAME="I3583"></A><A NAME="I3584"></A><A NAME="I3585"></A><A NAME="I3586"></A><A NAME="I3587"></A><A NAME="I3588"></A><A NAME="I3589"></A><A NAME="I3590"></A>After 
conversion of the value to the target type, if the target subtype is 
constrained, a check is performed that the value satisfies this constraint. 
If the target subtype excludes null, then a check is made that the value 
is not null. If predicate checks are enabled for the target subtype (see 
<A HREF="AA-3-2-4.html">3.2.4</A>), a check is performed that the <span class="insert4">value 
satisfies the predicates</span><span class="delete4">&nbsp;predicate</span> 
of the target subtype<span class="delete4">&nbsp;is satisfied for the value</span><span class="insert5">, 
unless the conversion is:</span>.<A NAME="I3591"></A><A NAME="I3592"></A> 
</div>
<div class="paranum"><a name="p51.a">51.a/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
The first check above is a Range_Check for scalar subtypes, a Discriminant_Check 
or Index_Check for access subtypes, and a Discriminant_Check for discriminated 
subtypes. The Length_Check for an array conversion is performed as part 
of the conversion to the target type. The check for exclusion of null 
is an Access_Check.&nbsp;</div>
<div class="paranum"><a name="p51.1">51.1/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0333-1.TXT">AI12-0333-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0432-1.TXT">AI12-0432-1</A></I>} 
<span class="insert5">a view conversion that is the target of an assignment 
statement and is not referenced with a <SPAN Class="swiss"><A HREF="AA-5-2-1.html#S0174">target_name</A></SPAN>, 
or an actual parameter of mode <B>out</B>; or</span></div>
<div class="paranum"><a name="p51.2">51.2/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0333-1.TXT">AI12-0333-1</A></I>} 
<span class="insert5">an implicit subtype conversion of an actual parameter 
of mode <B>out</B> to the nominal subtype of its formal parameter.</span> 
</div>
<div class="paranum"><a name="p51.b">51.b/5</a></div>
<div class="Annotations"><span class="insert5"><B>Ramification:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0333-1.TXT">AI12-0333-1</A></I>} 
<span class="insert5">The reverse conversion applied to by-copy <B>out</B> 
parameters is <I>not</I> a view conversion and it is to the nominal subtype 
of the <I>actual</I> parameter, therefore any enabled predicate checks 
<I>are</I> performed.</span>&nbsp;</div>
<div class="paranum"><a name="p52">52</a></div>
<div class="Normal"><A NAME="I3593"></A>For the evaluation of a view 
conversion, the operand <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is evaluated, and a new view of the object denoted by the operand is 
created, whose type is the target type; <A NAME="I3594"></A><A NAME="I3595"></A><A NAME="I3596"></A><A NAME="I3597"></A><A NAME="I3598"></A><A NAME="I3599"></A>if 
the target type is composite, checks are performed as above for a value 
conversion.</div>
<div class="paranum"><a name="p53">53</a></div>
<div class="Normal" style="margin-bottom: 0.4em">The properties of this 
new view are as follows:&nbsp;</div>
<div class="paranum"><a name="p54">54/1</a></div>
<div class="Bulleted">{<I><A HREF="defect1.html#8652/0017">8652/0017</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00184.TXT">AI95-00184-01</A></I>} 
If the target type is composite, the bounds or discriminants (if any) 
of the view are as defined above for a value conversion; each nondiscriminant 
component of the view denotes the matching component of the operand object; 
the subtype of the view is constrained if either the target subtype or 
the operand object is constrained, or if the target subtype is indefinite, 
or if the operand type is a descendant of the target type and has discriminants 
that were not inherited from the target type;</div>
<div class="paranum"><a name="p55">55/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0439-1.TXT">AI12-0439-1</A></I>} 
If the target type is tagged, then an assignment to the view assigns 
to the corresponding part of the object denoted by the operand; otherwise, 
an assignment to the view assigns to the object, after converting the 
assigned value to the subtype of the object (which <span class="insert5">can</span><span class="delete5">&nbsp;might</span> 
raise Constraint_Error); <A NAME="I3600"></A></div>
<div class="paranum"><a name="p56">56/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">AI12-0074-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0439-1.TXT">AI12-0439-1</A></I>} 
Reading the value of the view yields the result of converting the value 
of the operand object to the target subtype (which <span class="insert5">can</span><span class="delete5">&nbsp;might</span> 
raise Constraint_Error), except if the object is of an <span class="insert4">elementary</span><span class="delete4">&nbsp;access</span> 
type and the view conversion is passed as an <B>out</B> parameter; in 
this latter case, the value of the operand object <span class="insert4">may 
be</span><span class="delete4">&nbsp;is</span> used to initialize the formal 
parameter without checking against any constraint of the target subtype 
(<span class="insert4">as described more precisely in</span><span class="delete4">&nbsp;see</span> 
<A HREF="AA-6-4-1.html">6.4.1</A>). <A NAME="I3601"></A></div>
<div class="paranum"><a name="p56.a">56.a/4</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">AI12-0074-1</A></I>} 
This ensures that even an <B>out</B> parameter of an <span class="insert4">elementary</span><span class="delete4">&nbsp;access</span> 
type is initialized reasonably.&nbsp;</div>
<div class="paranum"><a name="p57">57/4</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0096-1.TXT">AI12-0096-1</A></I>} 
<A NAME="I3602"></A><A NAME="I3603"></A><A NAME="I3604"></A>If an Accessibility_Check 
fails, Program_Error is raised. If a predicate check fails, <span class="insert4">the 
effect is as defined in subclause <A HREF="AA-3-2-4.html">3.2.4</A>, 
&ldquo;<A HREF="AA-3-2-4.html">Subtype Predicates</A>&rdquo;</span><span class="delete4">&nbsp;Assertions.Assertion_Error 
is raised</span>. Any other check associated with a conversion raises 
Constraint_Error if it fails.</div>
<div class="paranum"><a name="p58">58</a></div>
<div class="Normal">Conversion to a type is the same as conversion to 
an unconstrained subtype of the type.&nbsp;</div>
<div class="paranum"><a name="p58.a">58.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>This definition is needed because 
the semantics of various constructs involves converting to a type, whereas 
an explicit <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
actually converts to a subtype. For example, the evaluation of a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
is defined to convert the values of the expressions to the type of the 
range.&nbsp;</div>
<div class="paranum"><a name="p58.b">58.b</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A conversion to a scalar 
type, or, equivalently, to an unconstrained scalar subtype, can raise 
Constraint_Error if the value is outside the base range of the type. 
</div>
<div class="paranum"><a name="p58.1">58.1/5</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0226-1.TXT">AI12-0226-1</A></I>} 
<span class="insert4">Evaluation of a value conversion of&nbsp;</span><span class="insert5">an 
object</span><span class="insert4"></span><span class="insert4"><span class="delete5">&nbsp;a 
composite type</span></span><span class="insert4">&nbsp;either creates a new 
anonymous object[ (similar to the object created by the evaluation of 
an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
or a function call)] or yields a new view of the operand object without 
creating a new object:</span></div>
<div class="paranum"><a name="p58.2">58.2/4</a></div>
<div class="Bulleted"><span class="insert4">If the target type is a by-reference 
type and there is a type that is an ancestor of both the target type 
and the operand type then no new object is created;</span></div>
<div class="paranum"><a name="p58.3">58.3/4</a></div>
<div class="Bulleted"><span class="insert4">If the target type is an 
array type having aliased components and the operand type is an array 
type having unaliased components, then a new object is created;</span></div>
<div class="paranum"><a name="p58.4">58.4/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0226-1.TXT">AI12-0226-1</A></I>} 
<span class="insert5">If the target type is an elementary type, then 
a new object is created;</span></div>
<div class="paranum"><a name="p58.5">58.5/5</a></div>
<div class="Bulleted"><span class="insert4">Otherwise, it is unspecified 
whether a new object is created.<A NAME="I3605"></A></span>&nbsp;</div>
<div class="paranum"><a name="p58.6">58.6/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<span class="insert4">If a new object is created, then the initialization 
of that object is an assignment operation.</span></div>
<div class="paranum"><a name="p58.c">58.c/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B>This makes 
a difference in the case of converting from an array type with unaliased 
components to one with aliased components if the element type has a controlled 
part.</span></div>
<div class="paranum"><a name="p58.d">58.d/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0226-1.TXT">AI12-0226-1</A></I>} 
<span class="insert5">For an elementary type, the representation might 
change so we require a new object to avoid problems.</span>&nbsp;</div>
<div class="paranum"><a name="p58.e">58.e/5</a></div>
<div class="Annotations"><span class="insert5"><B>Implementation Note: 
</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0226-1.TXT">AI12-0226-1</A></I>} 
<span class="insert5">The temporary object need not be materialized in 
most cases; it should be handled like the return object of a predefined 
operator. Generally, whether the object exists can only be detected if 
it is renamed (unless a part of the type is controlled).</span>&nbsp;</div>
<div class="paranum"><a name="p58.f">58.f/5</a></div>
<div class="Annotations"><span class="insert5"><B>Discussion:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0226-1.TXT">AI12-0226-1</A></I>} 
<span class="insert5">This set of rules does not apply in those cases 
where the operand is not an object (such as a value conversion of a named 
number); in such cases, the result isn't an object, so it isn't necessary 
to describe what that means. The rules cover all value conversions of 
composite types (since there aren't any values of composite types separate 
from objects).</span>&nbsp;</div>
<div class="paranum"><a name="p59">59</a></div>
<div class="Notes">NOTE 1&nbsp;&nbsp;&nbsp;<A NAME="I3606"></A>In addition 
to explicit <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN>s, 
type conversions are performed implicitly in situations where the expected 
type and the actual type of a construct differ, as is permitted by the 
type resolution rules (see <A HREF="AA-8-6.html">8.6</A>). For example, 
an integer literal is of the type <I>universal_integer</I>, and is implicitly 
converted when assigned to a target of some specific integer type. Similarly, 
an actual parameter of a specific tagged type is implicitly converted 
when the corresponding formal parameter is of a class-wide type.</div>
<div class="paranum"><a name="p60">60</a></div>
<div class="Notes"><A NAME="I3607"></A><A NAME="I3608"></A>Even when 
the expected and actual types are the same, implicit subtype conversions 
are performed to adjust the array bounds (if any) of an operand to match 
the desired target subtype, or to raise Constraint_Error if the (possibly 
adjusted) value does not satisfy the constraints of the target subtype.</div>
<div class="paranum"><a name="p61">61/2</a></div>
<div class="Notes">NOTE 2&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
A ramification of the overload resolution rules is that the operand of 
an (explicit) <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
cannot be an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0164">allocator</A></SPAN>, 
an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN>, 
or an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for an Access or Unchecked_Access attribute. Similarly, such an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0132">expression</A></SPAN> 
enclosed by parentheses is not allowed. A <SPAN Class="swiss"><A HREF="AA-4-7.html#S0163">qualified_expression</A></SPAN> 
(see <A HREF="AA-4-7.html">4.7</A>) can be used instead of such a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN>.</div>
<div class="paranum"><a name="p62">62</a></div>
<div class="Notes">NOTE 3&nbsp;&nbsp;&nbsp;The constraint of the target 
subtype has no effect for a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
of an elementary type passed as an <B>out</B> parameter. Hence, it is 
recommended that the first subtype be specified as the target to minimize 
confusion (a similar recommendation applies to renaming and generic formal 
<B>in out</B> objects).&nbsp;</div>

<H4 Class="centered">Examples</H4>
<div class="paranum"><a name="p63">63</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><I>Examples of numeric 
type conversion:</I>&nbsp;</div>
<div class="paranum"><a name="p64">64</a></div>
<div class="Examples">Real(2*J)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;value&nbsp;is&nbsp;converted&nbsp;to&nbsp;floating&nbsp;point</I></SPAN><BR>
Integer(1.6)&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;value&nbsp;is&nbsp;2</I></SPAN><BR>
Integer(-0.4)&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;value&nbsp;is&nbsp;0</I></SPAN></div>
<div class="paranum"><a name="p65">65</a></div>
<div class="WideAbove" style="margin-bottom: 0.4em"><I>Example of conversion 
between derived types:</I>&nbsp;</div>
<div class="paranum"><a name="p66">66</a></div>
<div class="Examples"><B>type</B>&nbsp;A_Form&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;B_Form;</div>
<div class="paranum"><a name="p67">67</a></div>
<div class="Examples">X&nbsp;:&nbsp;A_Form;<BR>
Y&nbsp;:&nbsp;B_Form;</div>
<div class="paranum"><a name="p68">68</a></div>
<div class="Examples">X&nbsp;:=&nbsp;A_Form(Y);<BR>
Y&nbsp;:=&nbsp;B_Form(X);&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;the&nbsp;reverse&nbsp;conversion&nbsp;</I></SPAN></div>
<div class="paranum"><a name="p69">69</a></div>
<div class="WideAbove" style="margin-bottom: 0.4em"><I>Examples of conversions 
between array types:</I>&nbsp;</div>
<div class="paranum"><a name="p70">70</a></div>
<div class="Examples"><B>type</B>&nbsp;Sequence&nbsp;<B>is</B>&nbsp;<B>array</B>&nbsp;(Integer&nbsp;<B>range</B>&nbsp;&lt;&gt;)&nbsp;<B>of</B>&nbsp;Integer;<BR>
<B>subtype</B>&nbsp;Dozen&nbsp;<B>is</B>&nbsp;Sequence(1&nbsp;..&nbsp;12);<BR>
Ledger&nbsp;:&nbsp;<B>array</B>(1&nbsp;..&nbsp;100)&nbsp;<B>of</B>&nbsp;Integer;</div>
<div class="paranum"><a name="p71">71</a></div>
<div class="Examples">Sequence(Ledger)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;bounds&nbsp;are&nbsp;those&nbsp;of&nbsp;Ledger</I></SPAN><BR>
Sequence(Ledger(31&nbsp;..&nbsp;42))&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;bounds&nbsp;are&nbsp;31&nbsp;and&nbsp;42</I></SPAN><BR>
Dozen(Ledger(31&nbsp;..&nbsp;42))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;&nbsp;bounds&nbsp;are&nbsp;those&nbsp;of&nbsp;Dozen&nbsp;</I></SPAN></div>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<div class="paranum"><a name="p71.a">71.a</a></div>
<div class="Annotations"><A NAME="I3609"></A>A <SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN> 
is not allowed as the operand of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN>, 
since there are now two character types in package Standard.</div>
<div class="paranum"><a name="p71.b">71.b</a></div>
<div class="Annotations">The component subtypes have to statically match 
in an array conversion, rather than being checked for matching constraints 
at run time.</div>
<div class="paranum"><a name="p71.c">71.c</a></div>
<div class="Annotations">Because sliding of array bounds is now provided 
for operations where it was not in Ada 83, programs that used to raise 
Constraint_Error might now continue executing and produce a reasonable 
result. This is likely to fix more bugs than it creates.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 83</H4>
<div class="paranum"><a name="p71.d">71.d</a></div>
<div class="Annotations"><A NAME="I3610"></A>A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is considered the name of an object in certain circumstances (such a 
<SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
is called a view conversion). In particular, as in Ada 83, a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN> 
can appear as an <B>in out</B> or <B>out</B> actual parameter. In addition, 
if the target type is tagged and the operand is the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of an object, then so is the <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN>, 
and it can be used as the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
to a <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0098">selected_component</A></SPAN>, 
in an <SPAN Class="swiss"><A HREF="AA-8-5-1.html#S0239">object_renaming_declaration</A></SPAN>, 
etc.</div>
<div class="paranum"><a name="p71.e">71.e</a></div>
<div class="Annotations">We no longer require type-mark conformance between 
a parameter of the form of a type conversion, and the corresponding formal 
parameter. This had caused some problems for inherited subprograms (since 
there isn't really a type-mark for converted formals), as well as for 
renamings, formal subprograms, etc. See AI83-00245, AI83-00318, AI83-00547.</div>
<div class="paranum"><a name="p71.f">71.f</a></div>
<div class="Annotations">We now specify &ldquo;deterministic&rdquo; rounding 
from real to integer types when the value of the operand is exactly between 
two integers (rounding is away from zero in this case).</div>
<div class="paranum"><a name="p71.g">71.g</a></div>
<div class="Annotations">&ldquo;Sliding&rdquo; of array bounds (which 
is part of conversion to an array subtype) is performed in more cases 
in Ada 95 than in Ada 83. Sliding is not performed on the operand of 
a membership test, nor on the operand of a <SPAN Class="swiss"><A HREF="AA-4-7.html#S0163">qualified_expression</A></SPAN>. 
It wouldn't make sense on a membership test, and we wish to retain a 
connection between subtype membership and subtype qualification. In general, 
a subtype membership test returns True if and only if a corresponding 
subtype qualification succeeds without raising an exception. Other operations 
that take arrays perform sliding.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<div class="paranum"><a name="p71.h">71.h</a></div>
<div class="Annotations">We no longer explicitly list the kinds of things 
that are not allowed as the operand of a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0162">type_conversion</A></SPAN>, 
except in a NOTE.</div>
<div class="paranum"><a name="p71.i">71.i/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0299-1.TXT">AI05-0299-1</A></I>} 
The rules in this subclause subsume the rules for &quot;parameters of 
the form of a type conversion&quot;, and have been generalized to cover 
the use of a type conversion as a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>. 
</div>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<div class="paranum"><a name="p71.j">71.j/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00246.TXT">AI95-00246-01</A></I>} 
<A NAME="I3611"></A><B>Amendment Correction:</B> Conversions between 
unrelated array types that are limited or (for view conversions) might 
be by-reference types are now illegal. The representations of two such 
arrays may differ, making the conversions impossible. We make the check 
here, because legality should not be based on representation properties. 
Such conversions are likely to be rare, anyway. There is a potential 
that this change would make a working program illegal (if the types have 
the same representation).</div>
<div class="paranum"><a name="p71.k">71.k/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
If a discriminated full type has a partial view (private type) that is 
constrained, we do not allow conversion between access-to-unconstrained 
and access-to-constrained subtypes designating the type. Ada 95 allowed 
this conversion and the declaration of various access subtypes, requiring 
that the designated object be constrained and thus making details of 
the implementation of the private type visible to the client of the private 
type. See <A HREF="AA-4-8.html">4.8</A> for more on this topic.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum"><a name="p71.l">71.l/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<A NAME="I3612"></A>Conversion rules for <I>universal_access</I> were 
defined. These allow the use of anonymous access values in equality tests 
(see <A HREF="AA-4-5-2.html">4.5.2</A>), and also allow the use of <B>null</B> 
in type conversions and other contexts that do not provide a single expected 
type.</div>
<div class="paranum"><a name="p71.m">71.m/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00384.TXT">AI95-00384-01</A></I>} 
A type conversion from an access-to-discriminated and unconstrained object 
to an access-to-discriminated and constrained one is allowed. Ada 95 
only allowed the reverse conversion, which was weird and asymmetric. 
Of course, a constraint check will be performed for this conversion. 
</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p71.n">71.n/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0017">8652/0017</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00184.TXT">AI95-00184-01</A></I>} 
<B>Corrigendum:</B> Wording was added to ensure that view conversions 
are constrained, and that a tagged view conversion has a tagged object. 
Both rules are needed to avoid having a way to change the discriminants 
of a constrained object.</div>
<div class="paranum"><a name="p71.o">71.o/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0008">8652/0008</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00168.TXT">AI95-00168-01</A></I>} 
<B>Corrigendum:</B> Wording was added to ensure that the aliased status 
of array components cannot change in a view conversion. This rule was 
needed to avoid having a way to change the discriminants of an aliased 
object. This rule was repealed later, as Ada 2005 allows changing the 
discriminants of an aliased object.</div>
<div class="paranum"><a name="p71.p">71.p/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
Wording was added to check subtypes that exclude null (see <A HREF="AA-3-10.html">3.10</A>).</div>
<div class="paranum"><a name="p71.q">71.q/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The organization of the legality rules was changed, both to make it clearer, 
and to eliminate an unintentional incompatibility with Ada 83. The old 
organization prevented type conversions between some types that were 
related by derivation (which Ada 83 always allowed).</div>
<div class="paranum"><a name="p71.r">71.r/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00330.TXT">AI95-00330-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
Clarified that an untagged type conversion appearing as a generic actual 
parameter for a generic <B>in out</B> formal parameter is not a view 
conversion (and thus is illegal). This confirms the ACATS tests, so all 
implementations already follow this interpretation.</div>
<div class="paranum"><a name="p71.s">71.s/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
Rules added by the Corrigendum to eliminate problems with discriminants 
of aliased components changing were removed, as we now generally allow 
discriminants of aliased components to be changed.</div>
<div class="paranum"><a name="p71.t">71.t/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00392.TXT">AI95-00392-01</A></I>} 
Accessibility checks on conversions involving types with anonymous access 
components were added. These components have the level of the type, and 
conversions can be between types at different levels, which could cause 
dangling access values in the absence of such checks.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2005</H4>
<div class="paranum"><a name="p71.u">71.u/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0148-1.TXT">AI05-0148-1</A></I>} 
<A NAME="I3613"></A>A stand-alone object of an anonymous access-to-object 
type now has dynamic accessibility. Normally, this will make programs 
legal that were illegal in Ada 2005. However, it is possible that a program 
that previously raised Program_Error now will not. It is very unlikely 
that an existing program intentionally depends on the exception being 
raised; the change is more likely to fix bugs than introduce them.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p71.v">71.v/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0115-1.TXT">AI05-0115-1</A></I>} 
<B>Correction:</B> Clarified that a root numeric type is not considered 
a common ancestor for a conversion.</div>
<div class="paranum"><a name="p71.w">71.w/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
Added rules so that predicate aspects (see <A HREF="AA-3-2-4.html">3.2.4</A>) 
are enforced on subtype conversion.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2012</H4>
<div class="paranum"><a name="p71.x">71.x/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0333-1.TXT">AI12-0333-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0432-1.TXT">AI12-0432-1</A></I>} 
<span class="insert5"><B>Correction:</B> Predicate checks are no longer 
made on any <B>out</B> parameters before a call (they're still made when 
the call returns). This was already true for elementary <B>out</B> parameters. 
If a program depends on a predicate check failing on an inbound <B>out</B> 
composite parameter, it will get an incorrect result. Similarly, predicate 
checks are no longer made on the view conversion of a target of an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0173">assignment_statement</A></SPAN>. 
Both of these cases seem quite unlikely, as programs (outside of ACATS 
tests) that depend on the failure of checks are very rare, and the predicate 
might be checking uninitialized components (making check failure unreliable).</span> 
</div>

<H4 Class="centered">Incompatibilities With Ada 2012</H4>
<div class="paranum"><a name="p71.y">71.y/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0095-1.TXT">AI12-0095-1</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Because of a rule added in 
<A HREF="AA-12-5-1.html">12.5.1</A>, the checks for the legality of an 
access type conversion in a generic body were strengthened to use an 
</span><span class="insert5">assume-the-worst</span><span class="insert4"></span><span class="insert4"><span class="delete5">&nbsp;assume 
the worst</span></span><span class="insert4">&nbsp;rule. This case is rather 
unlikely&nbsp;</span><span class="insert5">because</span><span class="insert4"></span><span class="insert4"><span class="delete5">&nbsp;as</span></span><span class="insert4">&nbsp;a formal private or derived type with discriminants is required along 
with a conversion between two access types whose designated types don't 
statically match, and any such programs were at risk having objects disappear 
while valid access values still pointed at them.</span>&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2012</H4>
<div class="paranum"><a name="p71.z">71.z/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Moved the generic boilerplate 
so that it covers all Legality Rules in this subclause. This was always 
intended, but it is not expected to change anything other than conversions 
between unrelated arrays.</span></div>
<div class="paranum"><a name="p71.aa">71.aa/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0027-1.TXT">AI12-0027-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Added a formal definition of 
the copy potentially created by a value conversion of a composite type, 
so properties like finalization and accessibility are properly defined. 
This model was always intended and expected (else <A HREF="AA-13-6.html">13.6</A> 
would not work), but it was not previously formally defined.</span></div>
<div class="paranum"><a name="p71.bb">71.bb/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0071-1.TXT">AI12-0071-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Updated wording of type conversions 
to use the new term &quot;satisfies the predicates&quot; (see <A HREF="AA-3-2-4.html">3.2.4</A>).</span></div>
<div class="paranum"><a name="p71.cc">71.cc/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">AI12-0074-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Clarified the wording describing 
the effect of view conversions of <B>out</B> parameters such that it 
is clear that the detailed effect is defined in <A HREF="AA-6-4-1.html">6.4.1</A>, 
not here.</span></div>
<div class="paranum"><a name="p71.dd">71.dd/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0096-1.TXT">AI12-0096-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Updated wording of type conversions 
so that the exception raise or other effect of a failed predicate check 
is as defined in <A HREF="AA-3-2-4.html">3.2.4</A>; we don't want to 
repeat those rules here. This doesn't change the behavior for predicate 
checks possible in original Ada 2012, only ones using the new aspect 
Predicate_Failure.</span></div>
<div class="paranum"><a name="p71.ee">71.ee/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0064-2.TXT">AI12-0064-2</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0380-1.TXT">AI12-0380-1</A></I>} 
<span class="insert5">Required Global (see <A HREF="AA-6-1-2.html">6.1.2</A>) 
and Nonblocking (see <A HREF="AA-9-5.html">9.5</A>) aspect matching for 
access-to-subprogram conversions.</span></div>
<div class="paranum"><a name="p71.ff">71.ff/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0226-1.TXT">AI12-0226-1</A></I>} 
<span class="insert5">Described the objects associated with value conversions 
of elementary types. This is necessary to support an extension documented 
in <A HREF="AA-3-3.html">3.3</A>.</span></div>
<div class="paranum"><a name="p71.gg">71.gg/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0392-1.TXT">AI12-0392-1</A></I>} 
<span class="insert5"><B>Correction:</B> Eliminated the requirement that 
the operand of a view conversion be a simple <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>. 
The requirement could cause unintended consequences in the case where 
the operand of a type conversion represents an object but is more complex 
than a simple <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
(such as a <SPAN Class="swiss"><A HREF="AA-4-7.html#S0163">qualified_expression</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-5-7.html#S0148">conditional_expression</A></SPAN>).</span> 
</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-10.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-7.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
