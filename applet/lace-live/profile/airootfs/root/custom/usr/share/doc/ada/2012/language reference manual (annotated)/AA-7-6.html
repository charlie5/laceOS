<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Assignment and Finalization</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallIndented1Examples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-6-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>7.6 Assignment and Finalization</H1>
<div class="paranum"><a name="p1">1</a></div>
<div class="Normal">[<A NAME="I3977"></A> <A NAME="I3978"></A>Three kinds 
of actions are fundamental to the manipulation of objects: initialization, 
finalization, and assignment. Every object is initialized, either explicitly 
or by default, after being created (for example, by an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>). 
Every object is finalized before being destroyed (for example, by leaving 
a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0177">subprogram_body</A></SPAN> 
containing an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN>, 
or by a call to an instance of Unchecked_Deallocation). An assignment 
operation is used as part of <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN>s, 
explicit initialization, parameter passing, and other operations. <A NAME="I3979"></A><A NAME="I3980"></A><A NAME="I3981"></A></div>
<div class="paranum"><a name="p2">2</a></div>
<div class="Normal">Default definitions for these three fundamental operations 
are provided by the language, but <A NAME="I3982"></A>a <I>controlled</I> 
type gives the user additional control over parts of these operations. 
<A NAME="I3983"></A><A NAME="I3984"></A><A NAME="I3985"></A>In particular, 
the user can define, for a controlled type, an Initialize procedure which 
is invoked immediately after the normal default initialization of a controlled 
object, a Finalize procedure which is invoked immediately before finalization 
of any of the components of a controlled object, and an Adjust procedure 
which is invoked as the last step of an assignment to a (nonlimited) 
controlled object.]&nbsp;</div>
<div class="paranum"><a name="p2.a">2.a</a></div>
<div class="Annotations"><B>Glossary entry:&nbsp;</B>A controlled type supports 
user-defined assignment and finalization. Objects are always finalized 
before being destroyed.</div>
<div class="paranum"><a name="p2.b">2.b/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00287.TXT">AI95-00287-01</A></I>} 
Here's the basic idea of initialization, value adjustment, and finalization, 
whether or not user defined: When an object is created, if it is explicitly 
assigned an initial value, the object is either built-in-place from an 
<SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
or function call (in which case neither Adjust nor Initialize is applied), 
or the assignment copies and adjusts the initial value. Otherwise, Initialize 
is applied to it (except in the case of an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
as a whole). An <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN> 
finalizes the target before copying in and adjusting the new value. Whenever 
an object goes away, it is finalized. Calls on Initialize and Adjust 
happen bottom-up; that is, components first, followed by the containing 
object. Calls on Finalize happen top-down; that is, first the containing 
object, and then its components. These ordering rules ensure that any 
components will be in a well-defined state when Initialize, Adjust, or 
Finalize is applied to the containing object.&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p3">3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">The following language-defined 
library package exists:&nbsp;</div>
<div class="paranum"><a name="p4">4/3</a></div>
<div class="Examples">{<I><A HREF="defect1.html#8652/0020">8652/0020</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00126.TXT">AI95-00126-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0212-1.TXT">AI05-0212-1</A></I>} 
<B>package</B>&nbsp;Ada.Finalization&nbsp;<B>is</B><A NAME="I3986"></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Pure(Finalization);</div>
<div class="paranum"><a name="p5">5/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I3987"></A>Controlled&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Controlled);</div>
<div class="paranum"><a name="p6">6/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3988"></A>Initialize&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Controlled)&nbsp;<B>is&nbsp;null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3989"></A>Adjust&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Controlled)&nbsp;<B>is&nbsp;null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3990"></A>Finalize&nbsp;&nbsp;&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Controlled)&nbsp;<B>is&nbsp;null</B>;</div>
<div class="paranum"><a name="p7">7/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I3991"></A>Limited_Controlled&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;limited&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Limited_Controlled);</div>
<div class="paranum"><a name="p8">8/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3992"></A>Initialize&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Limited_Controlled)&nbsp;<B>is&nbsp;null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3993"></A>Finalize&nbsp;&nbsp;&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Limited_Controlled)&nbsp;<B>is&nbsp;null</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;--&nbsp;<SPAN Class="roman"><I>not&nbsp;specified&nbsp;by&nbsp;the&nbsp;language</I></SPAN><BR>
<B>end</B>&nbsp;Ada.Finalization;</div>
<div class="paranum"><a name="p9">9/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
<A NAME="I3994"></A>A controlled type is a descendant of Controlled or 
Limited_Controlled. The predefined &quot;=&quot; operator of type Controlled 
always returns True, [since this operator is incorporated into the implementation 
of the predefined equality operator of types derived from Controlled, 
as explained in <A HREF="AA-4-5-2.html">4.5.2</A>.] The type Limited_Controlled 
is like Controlled, except that it is limited and it lacks the primitive 
subprogram Adjust.&nbsp;</div>
<div class="paranum"><a name="p9.a">9.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>We say &ldquo;nonlimited 
controlled type&rdquo;&nbsp;(rather than just &ldquo;controlled type&rdquo;;) 
when we want to talk about descendants of Controlled only.&nbsp;</div>
<div class="paranum"><a name="p9.b">9.b</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>We considered making Adjust and 
Finalize abstract. However, a reasonable coding convention is e.g. for 
Finalize to always call the parent's Finalize after doing whatever work 
is needed for the extension part. (Unlike CLOS, we have no way to do 
that automatically in Ada 95.) For this to work, Finalize cannot be abstract. 
In a generic unit, for a generic formal abstract derived type whose ancestor 
is Controlled or Limited_Controlled, calling the ancestor's Finalize 
would be illegal if it were abstract, even though the actual type might 
have a concrete version.</div>
<div class="paranum"><a name="p9.c">9.c</a></div>
<div class="Annotations">Types Controlled and Limited_Controlled are 
abstract, even though they have no abstract primitive subprograms. It 
is not clear that they need to be abstract, but there seems to be no 
harm in it, and it might make an implementation's life easier to know 
that there are no objects of these types &mdash; in case the implementation 
wishes to make them &ldquo;magic&rdquo; in some way.</div>
<div class="paranum"><a name="p9.d">9.d/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
For Ada 2005, we considered making these types interfaces. That would 
have the advantage of allowing them to be added to existing trees. But 
that was rejected both because it would cause massive disruptions to 
existing implementations, and because it would be very incompatible due 
to the &quot;no hidden interfaces&quot; rule. The latter rule would prevent 
a tagged private type from being completed with a derivation from Controlled 
or Limited_Controlled &mdash; a very common idiom.&nbsp;</div>
<div class="paranum"><a name="p9.1">9.1/2</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00360.TXT">AI95-00360-01</A></I>} 
A type is said to <I>need finalization</I> if:<A NAME="I3995"></A><A NAME="I3996"></A></div>
<div class="paranum"><a name="p9.2">9.2/2</a></div>
<div class="Bulleted">it is a controlled type, a task type or a protected 
type; or</div>
<div class="paranum"><a name="p9.3">9.3/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0092-1.TXT">AI05-0092-1</A></I>} 
it has a component whose type  needs finalization; or</div>
<div class="paranum"><a name="p9.4">9.4/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0013-1.TXT">AI05-0013-1</A></I>} 
it is a class-wide type; or</div>
<div class="paranum"><a name="p9.5">9.5/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0026-1.TXT">AI05-0026-1</A></I>} 
it is a partial view whose full view needs finalization; or</div>
<div class="paranum"><a name="p9.6">9.6/2</a></div>
<div class="Bulleted">it is one of a number of language-defined types 
that are explicitly defined to need finalization.</div>
<div class="paranum"><a name="p9.e">9.e/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The fact that a type needs 
finalization does not require it to be implemented with a controlled 
type. It just has to be recognized by the No_Nested_Finalization restriction.</div>
<div class="paranum"><a name="p9.f">9.f/2</a></div>
<div class="Annotations">This property is defined for the type, not for 
a particular view. That's necessary as restrictions look in private parts 
to enforce their restrictions; the point is to eliminate all controlled 
parts, not just ones that are visible.&nbsp;</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p10">10/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
During the elaboration or evaluation of a construct that causes an object 
to be initialized by default, for every controlled subcomponent of the 
object that is not assigned an initial value (as defined in <A HREF="AA-3-3-1.html">3.3.1</A>), 
Initialize is called on that subcomponent. Similarly, if the object that 
is initialized by default as a whole is controlled, Initialize is called 
on the object.</div>
<div class="paranum"><a name="p11">11/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
For an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0112">ancestor_part</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denoting a controlled subtype, the Initialize procedure of the ancestor 
type is called, unless that Initialize procedure is abstract.&nbsp;</div>
<div class="paranum"><a name="p11.a">11.a</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Discussion: 
</B>Example:&nbsp;</div>
<div class="paranum"><a name="p11.b">11.b</a></div>
<div class="SmallExamples"><B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Controlled&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;--<SPAN Class="roman"><I>&nbsp;some&nbsp;components&nbsp;might&nbsp;have&nbsp;defaults</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</div>
<div class="paranum"><a name="p11.c">11.c</a></div>
<div class="SmallExamples"><B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Controlled&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;T1;&nbsp;--<SPAN Class="roman"><I>&nbsp;no&nbsp;default</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;T1&nbsp;:=&nbsp;...;&nbsp;--<SPAN Class="roman"><I>&nbsp;default</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</div>
<div class="paranum"><a name="p11.d">11.d</a></div>
<div class="SmallExamples">A&nbsp;:&nbsp;T2;<BR>
B&nbsp;:&nbsp;T2&nbsp;:=&nbsp;...;</div>
<div class="paranum"><a name="p11.e">11.e</a></div>
<div class="Annotations">As part of the elaboration of A's declaration, 
A.Y is assigned a value; therefore Initialize is not applied to A.Y. 
Instead, Adjust is applied to A.Y as part of the assignment operation. 
Initialize is applied to A.X and to A, since those objects are not assigned 
an initial value. The assignment to A.Y is not considered an assignment 
to A.</div>
<div class="paranum"><a name="p11.f">11.f</a></div>
<div class="Annotations">For the elaboration of B's declaration, Initialize 
is not called at all. Instead the assignment adjusts B's value; that 
is, it applies Adjust to B.X, B.Y, and B.</div>
<div class="paranum"><a name="p11.f.1">11.f.1/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
The <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0112">ancestor_part</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN>, 
&lt;&gt; in aggregates, and the return object of an <SPAN Class="swiss"><A HREF="AA-6-5.html#S0186">extended_return_statement</A></SPAN> 
are handled similarly.&nbsp;</div>
<div class="paranum"><a name="p12">12</a></div>
<div class="Normal">Initialize and other initialization operations are 
done in an arbitrary order, except as follows.<A NAME="I3997"></A> Initialize 
is applied to an object after initialization of its subcomponents, if 
any [(including both implicit initialization and Initialize calls)]. 
If an object has a component with an access discriminant constrained 
by a per-object expression, Initialize is applied to this component after 
any components that do not have such discriminants. For an object with 
several components with such a discriminant, Initialize is applied to 
them in order of their <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN>s. 
For an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>, 
any task activations follow all calls on Initialize.&nbsp;</div>
<div class="paranum"><a name="p12.a">12.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>The fact that Initialize is done 
for subcomponents first allows Initialize for a composite object to refer 
to its subcomponents knowing they have been properly initialized.</div>
<div class="paranum"><a name="p12.b">12.b</a></div>
<div class="Annotations">The fact that Initialize is done for components 
with access discriminants after other components allows the Initialize 
operation for a component with a self-referential access discriminant 
to assume that other components of the enclosing object have already 
been properly initialized. For multiple such components, it allows some 
predictability.&nbsp;</div>
<div class="paranum"><a name="p13">13</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I3998"></A>When 
a target object with any controlled parts is assigned a value, [either 
when created or in a subsequent <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN>,] 
the <I>assignment operation</I> proceeds as follows:&nbsp;</div>
<div class="paranum"><a name="p14">14</a></div>
<div class="Bulleted">The value of the target becomes the assigned value.</div>
<div class="paranum"><a name="p15">15</a></div>
<div class="Bulleted"><A NAME="I3999"></A><A NAME="I4000"></A>The value 
of the target is <I>adjusted.</I>&nbsp;</div>
<div class="paranum"><a name="p15.a">15.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>If any parts of the object 
are controlled, abort is deferred during the assignment operation.&nbsp;</div>
<div class="paranum"><a name="p16">16/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
<A NAME="I4001"></A><A NAME="I4002"></A>To adjust the value of a composite 
object, the values of the components of the object are first adjusted 
in an arbitrary order, and then, if the object is nonlimited controlled, 
Adjust is called.<A NAME="I4003"></A> Adjusting the value of an elementary 
object has no effect[, nor does adjusting the value of a composite object 
with no controlled parts.]&nbsp;</div>
<div class="paranum"><a name="p16.a">16.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
Adjustment is never actually performed for values of an immutably limited 
type, since all assignment operations for such types are required to 
be built-in-place. Even so, we still define adjustment for all types 
in order that the canonical semantics is well-defined.&nbsp;</div>
<div class="paranum"><a name="p16.b">16.b/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
The verbiage in the Initialize rule about access discriminants constrained 
by per-object expressions is not necessary here, since such types are 
either limited or do not have defaults, so the discriminant can only 
be changed by an assignment to an outer object. Such an assignment could 
happen only before any adjustments or (if part of an outer Adjust) only 
after any inner (component) adjustments have completed.&nbsp;</div>
<div class="paranum"><a name="p17">17</a></div>
<div class="Normal"><A NAME="I4004"></A>For an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN>, 
[ after the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
and <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN> 
have been evaluated, and any conversion (including constraint checking) 
has been done,] an anonymous object is created, and the value is assigned 
into it; [that is, the assignment operation is applied]. [(Assignment 
includes value adjustment.)] The target of the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN> 
is then finalized. The value of the anonymous object is then assigned 
into the target of the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN>. 
Finally, the anonymous object is finalized. [As explained below, the 
implementation may eliminate the intermediate anonymous object, so this 
description subsumes the one given in <A HREF="AA-5-2.html">5.2</A>, 
&ldquo;<A HREF="AA-5-2.html">Assignment Statements</A>&rdquo;.]&nbsp;</div>
<div class="paranum"><a name="p17.a">17.a</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>An 
alternative design for user-defined assignment might involve an Assign 
operation instead of Adjust:&nbsp;</div>
<div class="paranum"><a name="p17.b">17.b</a></div>
<div class="SmallExamples"><B>procedure</B>&nbsp;Assign(Target&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled;&nbsp;Source&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled);</div>
<div class="paranum"><a name="p17.c">17.c</a></div>
<div class="Annotations" style="margin-bottom: 0.4em">Or perhaps even 
a syntax like this:&nbsp;</div>
<div class="paranum"><a name="p17.d">17.d</a></div>
<div class="SmallExamples"><B>procedure</B>&nbsp;&quot;:=&quot;(Target&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled;&nbsp;Source&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled);</div>
<div class="paranum"><a name="p17.e">17.e</a></div>
<div class="Annotations" style="margin-bottom: 0.4em">Assign (or &quot;:=&quot;) 
would have the responsibility of doing the copy, as well as whatever 
else is necessary. This would have the advantage that the Assign operation 
knows about both the target and the source at the same time &mdash; it 
would be possible to do things like reuse storage belonging to the target, 
for example, which Adjust cannot do. However, this sort of design would 
not work in the case of unconstrained discriminated variables, because 
there is no way to change the discriminants individually. For example: 
</div>
<div class="paranum"><a name="p17.f">17.f</a></div>
<div class="SmallExamples"><B>type</B>&nbsp;Mutable(D&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;0)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Array_Of_Controlled_Things(1..D);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;D&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;17&nbsp;=&gt;&nbsp;Y&nbsp;:&nbsp;Controlled_Thing;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;<B>others</B>&nbsp;=&gt;&nbsp;<B>null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;D;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</div>
<div class="paranum"><a name="p17.g">17.g</a></div>
<div class="Annotations">An assignment to an unconstrained variable of 
type Mutable can cause some of the components of X, and the component 
Y, to appear and/or disappear. There is no way to write the Assign operation 
to handle this sort of case.</div>
<div class="paranum"><a name="p17.h">17.h</a></div>
<div class="Annotations">Forbidding such cases is not an option &mdash; 
it would cause generic contract model violations.&nbsp;</div>
<div class="paranum"><a name="p17.1">17.1/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
When a function call or <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
is used to initialize an object, the result of the function call or <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
is an anonymous object, which is assigned into the newly-created object. 
For such an assignment, the anonymous object might be <I>built in place</I>,<A NAME="I4005"></A><A NAME="I4006"></A> 
in which case the assignment does not involve any copying. Under certain 
circumstances, the anonymous object is required to be built in place. 
In particular:</div>
<div class="paranum"><a name="p17.i">17.i/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
We say assignment to built-in-place objects does not involve copying, 
which matches the intended implementation (see below). Of course, the 
implementation can do any copying it likes, if it can make such copying 
semantically invisible (by patching up access values to point to the 
copy, and so forth).&nbsp;</div>
<div class="paranum"><a name="p17.2">17.2/3</a></div>
<div class="Bulleted">If the full type of any part of the object is immutably 
limited, the anonymous object is built in place.</div>
<div class="paranum"><a name="p17.j">17.j/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
We talk about the full types being immutably limited, as this is independent 
of the view of a type (in the same way that it is for determining the 
technique of parameter passing). That is, privacy is ignored for this 
purpose.</div>
<div class="paranum"><a name="p17.k">17.k/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
For function calls, we only require building in place for immutably limited 
types. These are the types that would have been return-by-reference types 
in Ada 95. We limited the requirement because we want to minimize disruption 
to Ada 95 implementations and users.&nbsp;</div>
<div class="paranum"><a name="p17.l">17.l/3</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0232-1.TXT">AI05-0232-1</A></I>} 
This is a dynamic property and is determined by the specific type of 
the parts of the actual object. In particular, if a part has a class-wide 
type, the tag of the object might need to be examined in order to determine 
if build-in-place is required. However, we expect that most Ada implementations 
will determine this property at compile-time using some assume-the-worst 
algorithm in order to chose the appropriate method to implement a given 
call or aggregate. In addition, there is no attribute or other method 
for a program to determine if a particular object has this property (or 
not), so there is no value to a more careful description of this rule. 
</div>
<div class="paranum"><a name="p17.3">17.3/3</a></div>
<div class="Bulleted">In the case of an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>, 
if the full type of any part of the newly-created object is controlled, 
the anonymous object is built in place.</div>
<div class="paranum"><a name="p17.m">17.m/3</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
This is necessary to prevent elaboration problems with deferred constants 
of controlled types. Consider:&nbsp;</div>
<div class="paranum"><a name="p17.m.1">17.m.1/3</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Dyn_String&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;Null_String&nbsp;:&nbsp;<B>constant</B>&nbsp;Dyn_String;<BR>
&nbsp;&nbsp;&nbsp;...<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Dyn_String&nbsp;<B>is&nbsp;new</B>&nbsp;Ada.Finalization.Controlled&nbsp;<B>with</B>&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Finalize(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Dyn_String);<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Adjust(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Dyn_String);<BR>
<BR>
&nbsp;&nbsp;&nbsp;Null_String&nbsp;:&nbsp;<B>constant</B>&nbsp;Dyn_String&nbsp;:=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Ada.Finalization.Controlled&nbsp;<B>with</B>&nbsp;...);<BR>
&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>&nbsp;P;</div>
<div class="paranum"><a name="p17.m.2">17.m.2/3</a></div>
<div class="Annotations">When Null_String is elaborated, the bodies of 
Finalize and Adjust clearly have not been elaborated. Without this rule, 
this declaration would necessarily raise Program_Error (unless the permissions 
given below are used by the implementation).&nbsp;</div>
<div class="paranum"><a name="p17.n">17.n/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>An <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
with a controlled part used in the return expression of a <SPAN Class="swiss"><A HREF="AA-6-5.html#S0183">simple_return_statement</A></SPAN> 
has to be built in place in the anonymous return object, as this is similar 
to an object declaration. (This is a change from Ada 95, but it is not 
an inconsistency as it only serves to restrict implementation choices.) 
But this only covers the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>; 
a separate anonymous return object can still be used unless it too is 
required to be built in place.</div>
<div class="paranum"><a name="p17.o">17.o/3</a></div>
<div class="Annotations">Similarly, an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
that has a controlled part but is not itself controlled and that is used 
to initialize an object also has to be built in place. This is also a 
change from Ada 95, but it is not an inconsistency as it only serves 
to restrict implementation choices. This avoids problems if a type like 
Dyn_String (in the example above) is used as a component in a type used 
as a deferred constant in package P.&nbsp;</div>
<div class="paranum"><a name="p17.4">17.4/3</a></div>
<div class="Bulleted">In other cases, it is unspecified whether the anonymous 
object is built in place.<A NAME="I4007"></A></div>
<div class="paranum"><a name="p17.p">17.p/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>This is left unspecified so the 
implementation can use any appropriate criteria for determining when 
to build in place. That includes making the decision on a call-by-call 
basis. Reasonable programs will not care what decision is made here anyway. 
</div>
<div class="paranum"><a name="p17.5">17.5/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
Notwithstanding<A NAME="I4008"></A> what this International Standard 
says elsewhere, if an object is built in place:</div>
<div class="paranum"><a name="p17.6">17.6/3</a></div>
<div class="Bulleted">Upon successful completion of the return statement 
or <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>, 
the anonymous object <I>mutates into</I> the newly-created object; that 
is, the anonymous object ceases to exist, and the newly-created object 
appears in its place.<A NAME="I4009"></A></div>
<div class="paranum"><a name="p17.7">17.7/3</a></div>
<div class="Bulleted">Finalization is not performed on the anonymous 
object.</div>
<div class="paranum"><a name="p17.8">17.8/3</a></div>
<div class="Bulleted">Adjustment is not performed on the newly-created 
object.</div>
<div class="paranum"><a name="p17.9">17.9/3</a></div>
<div class="Bulleted">All access values that designate parts of the anonymous 
object now designate the corresponding parts of the newly-created object.</div>
<div class="paranum"><a name="p17.10">17.10/3</a></div>
<div class="Bulleted">All renamings of parts of the anonymous object 
now denote views of the corresponding parts of the newly-created object.</div>
<div class="paranum"><a name="p17.11">17.11/3</a></div>
<div class="Bulleted">Coextensions of the anonymous object become coextensions 
of the newly-created object.&nbsp;</div>
<div class="paranum"><a name="p17.q">17.q/3</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>This &ldquo;mutating&rdquo; 
does not necessarily happen atomically with respect to abort and other 
tasks. For example, if a function call is used as the parent part of 
an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN>, 
then the tag of the anonymous object (the function result) will be different 
from the tag of the newly-created object (the parent part of the <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN>). 
In implementation terms, this involves modifying the tag field. If the 
current task is aborted during this modification, the object might become 
abnormal. Likewise, if some other task accesses the tag field during 
this modification, it constitutes improper use of shared variables, and 
is erroneous.&nbsp;</div>
<div class="paranum"><a name="p17.r">17.r/3</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>The intended implementation 
is that the anonymous object is allocated at the same address as the 
newly-created object. Thus, no run-time action is required to cause all 
the access values and renamings to point to the right place. They just 
point to the newly-created object, which is what the return object has 
magically &ldquo;mutated into&rdquo;.</div>
<div class="paranum"><a name="p17.s">17.s/3</a></div>
<div class="Annotations">There is no requirement that 'Address of the 
return object is equal to 'Address of the newly-created object, but that 
will be true in the intended implementation.</div>
<div class="paranum"><a name="p17.t">17.t/3</a></div>
<div class="Annotations">For a function call, if the size of the newly-created 
object is known at the call site, the object is allocated there, and 
the address is implicitly passed to the function; the return object is 
created at that address. Otherwise, a storage pool is implicitly passed 
to the function; the size is determined at the point of the return statement, 
and passed to the Allocate procedure. The address returned by the storage 
pool is returned from the function, and the newly-created object uses 
that same address. If the return statement is left without returning 
(via an exception or a goto, for example), then Deallocate is called. 
 The storage pool might be a dummy pool that represents &ldquo;allocate 
on the stack&rdquo;.</div>
<div class="paranum"><a name="p17.u">17.u/3</a></div>
<div class="Annotations">The Tag of the newly-created object may be different 
from that of the result object. Likewise, the master and accessibility 
level may be different.</div>
<div class="paranum"><a name="p17.v">17.v/3</a></div>
<div class="Annotations">An alternative implementation model might allow 
objects to move around to different addresses. In this case, access values 
and renamings would need to be modified at run time. It seems that this 
model requires the full power of tracing garbage collection.&nbsp;</div>

<H4 Class="centered">Implementation Requirements</H4>
<div class="paranum"><a name="p17.12">17.12/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0022">8652/0022</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00083.TXT">AI95-00083-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
</div>
<div class="paranum"><a name="p17.v.1">17.v.1/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
</div>
<div class="paranum"><a name="p17.v.2">17.v.2/3</a></div>
<div class="SmallIndented1Examples"></div>
<div class="paranum"><a name="p17.v.3">17.v.3/3</a></div>
<div class="Annotations"></div>
<div class="paranum"><a name="p17.v.4">17.v.4/3</a></div>
<div class="Annotations"></div>

<H4 Class="centered">Implementation Permissions</H4>
<div class="paranum"><a name="p18">18/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
An implementation is allowed to relax the above rules for <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN>s 
in the following ways:&nbsp;</div>
<div class="paranum"><a name="p18.a">18.a/3</a></div>
<div class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
</div>
<div class="paranum"><a name="p18.b">18.b/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
The relaxations apply only to nonlimited types, as <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN>s 
are not allowed for limited types. This is important so that the programmer 
can count on a stricter semantics for limited controlled types.&nbsp;</div>
<div class="paranum"><a name="p19">19/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
If an object is assigned the value of that same object, the implementation 
need not do anything.&nbsp;</div>
<div class="paranum"><a name="p19.a">19.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>In other words, even if 
an object is controlled and a combination of Finalize and Adjust on the 
object might have a net side effect, they need not be performed.&nbsp;</div>
<div class="paranum"><a name="p20">20/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
For assignment of a noncontrolled type, the implementation may finalize 
and assign each component of the variable separately (rather than finalizing 
the entire variable and assigning the entire new value) unless a discriminant 
of the variable is changed by the assignment.&nbsp;</div>
<div class="paranum"><a name="p20.a">20.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>For example, in a slice assignment, 
an anonymous object is not necessary if the slice is copied component-by-component 
in the right direction, since array types are not controlled (although 
their components may be). Note that the direction, and even the fact 
that it's a slice assignment, can in general be determined only at run 
time.&nbsp;</div>
<div class="paranum"><a name="p20.b">20.b/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
This potentially breaks a single assignment operation into many, and 
thus abort deferral (see <A HREF="AA-9-8.html">9.8</A>) needs to last 
only across an individual component assignment when the component has 
a controlled part. It is only important that the copy step is not separated 
(by an abort) from the adjust step, so aborts between component assignments 
is not harmful.&nbsp;</div>
<div class="paranum"><a name="p21">21/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
The implementation need not create an anonymous object if the value being 
assigned is the result of evaluating a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
denoting an object (the source object) whose storage cannot overlap with 
the target. If the source object might overlap with the target object, 
then the implementation can avoid the need for an intermediary anonymous 
object by exercising one of the above permissions and perform the assignment 
one component at a time (for an overlapping array assignment), or not 
at all (for an assignment where the target and the source of the assignment 
are the same object).&nbsp;</div>
<div class="paranum"><a name="p21.a">21.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
If the anonymous object is eliminated by this permission,  there is no 
anonymous object to be finalized and thus the Finalize call on it is 
eliminated.</div>
<div class="paranum"><a name="p21.b">21.b/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
Note that if the anonymous object is eliminated but the new value is 
not built in place in the target object, that Adjust must be called directly 
on the target object as the last step of the assignment, since some of 
the subcomponents may be self-referential or otherwise position-dependent. 
This Adjust can be eliminated only by using one of the following permissions. 
</div>
<div class="paranum"><a name="p22">22/2</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
Furthermore, an implementation is permitted to omit implicit Initialize, 
Adjust, and Finalize calls and associated assignment operations on an 
object of a nonlimited controlled type provided that:</div>
<div class="paranum"><a name="p23">23/2</a></div>
<div class="Bulleted">any omitted Initialize call is not a call on a 
user-defined Initialize procedure, and&nbsp;</div>
<div class="paranum"><a name="p23.a">23.a/2</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>This does not apply to 
any calls to a user-defined Initialize routine that happen to occur in 
an Adjust or Finalize routine. It is intended that it is never necessary 
to look inside of an Adjust or Finalize routine to determine if the call 
can be omitted.&nbsp;</div>
<div class="paranum"><a name="p23.b">23.b/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>We don't want to eliminate objects 
for which the Initialize might have side effects (such as locking a resource). 
</div>
<div class="paranum"><a name="p24">24/2</a></div>
<div class="Bulleted">any usage of the value of the object after the 
implicit Initialize or Adjust call and before any subsequent Finalize 
call on the object does not change the external effect of the program, 
and</div>
<div class="paranum"><a name="p25">25/2</a></div>
<div class="Bulleted">after the omission of such calls and operations, 
any execution of the program that executes an Initialize or Adjust call 
on an object or initializes an object by an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
will also later execute a Finalize call on the object and will always 
do so prior to assigning a new value to the object, and</div>
<div class="paranum"><a name="p26">26/2</a></div>
<div class="Bulleted">the assignment operations associated with omitted 
Adjust calls are also omitted.&nbsp;</div>
<div class="paranum"><a name="p27">27/2</a></div>
<div class="Normal">&nbsp;This permission applies to Adjust and Finalize calls 
even if the implicit calls have additional external effects.&nbsp;</div>
<div class="paranum"><a name="p27.a">27.a/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>The goal of the above permissions 
is to allow typical dead assignment and dead variable removal algorithms 
to work for nonlimited controlled types. We require that &ldquo;pairs&rdquo; 
of Initialize/Adjust/Finalize operations are removed. (These aren't always 
pairs, which is why we talk about &ldquo;any execution of the program&rdquo;.) 
</div>

<H4 Class="centered">Extensions to Ada 83</H4>
<div class="paranum"><a name="p27.b">27.b</a></div>
<div class="Annotations"><A NAME="I4010"></A>Controlled types and user-defined 
finalization are new to Ada 95. (Ada 83 had finalization semantics only 
for masters of tasks.)&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum"><a name="p27.c">27.c/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<A NAME="I4011"></A><B>Amendment Correction:</B> Types Controlled and 
Limited_Controlled now have Preelaborable_Initialization, so that objects 
of types derived from these types can be used in preelaborated packages. 
</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p27.d">27.d/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0020">8652/0020</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00126.TXT">AI95-00126-01</A></I>} 
<B>Corrigendum:</B> Clarified that Ada.Finalization is a remote types 
package.</div>
<div class="paranum"><a name="p27.e">27.e/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
<B>Corrigendum:</B> Added wording to clarify that the default initialization 
(whatever it is) of an ancestor part is used.</div>
<div class="paranum"><a name="p27.f">27.f/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0022">8652/0022</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00083.TXT">AI95-00083-01</A></I>} 
<B>Corrigendum:</B> Clarified that Adjust is never called on an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
used for the initialization of an object or subaggregate, or passed as 
a parameter.</div>
<div class="paranum"><a name="p27.g">27.g/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
Additional optimizations are allowed for nonlimited controlled types. 
These allow traditional dead variable elimination to be applied to such 
types.</div>
<div class="paranum"><a name="p27.h">27.h/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
Corrected the build-in-place requirement for controlled <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>s 
to be consistent with the requirements for limited types.</div>
<div class="paranum"><a name="p27.i">27.i/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
The operations of types Controlled and Limited_Controlled are now declared 
as null procedures (see <A HREF="AA-6-7.html">6.7</A>) to make the semantics 
clear (and to provide a good example of what null procedures can be used 
for).</div>
<div class="paranum"><a name="p27.j">27.j/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00360.TXT">AI95-00360-01</A></I>} 
Types that need finalization are defined; this is used by the No_Nested_Finalization 
restriction (see <A HREF="AA-D-7.html">D.7</A>, &ldquo;<A HREF="AA-D-7.html">Tasking 
Restrictions</A>&rdquo;).</div>
<div class="paranum"><a name="p27.k">27.k/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
Generalized the description of objects that have Initialize called for 
them to say that it is done for all objects that are initialized by default. 
This is needed so that all of the new cases are covered.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2005</H4>
<div class="paranum"><a name="p27.l">27.l/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0212-1.TXT">AI05-0212-1</A></I>} 
<A NAME="I4012"></A>Package Ada.Finalization now has Pure categorization, 
so it can be mentioned for any package. Note that this does not change 
the preelaborability of objects descended from Controlled and Limited_Controlled. 
</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p27.m">27.m/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0013-1.TXT">AI05-0013-1</A></I>} 
<B>Correction:</B> Eliminated coextensions from the &ldquo;needs finalization&rdquo; 
rules, as this cannot be determined in general in the compilation unit 
that declares the type. (The designated type of the coextension may have 
been imported as a limited view.) Uses of &ldquo;needs finalization&rdquo; 
need to ensure that coextensions are handled by other means (such as 
in No_Nested_Finalization &ndash; see <A HREF="AA-D-7.html">D.7</A>) 
or that coextensions cannot happen.</div>
<div class="paranum"><a name="p27.n">27.n/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0013-1.TXT">AI05-0013-1</A></I>} 
<B>Correction:</B> Corrected the &ldquo;needs finalization&rdquo; rules 
to include class-wide types, as a future extension can include a part 
that needs finalization.</div>
<div class="paranum"><a name="p27.o">27.o/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0026-1.TXT">AI05-0026-1</A></I>} 
<B>Correction:</B> Corrected the &ldquo;needs finalization&rdquo; rules 
to clearly say that they ignore privacy.</div>
<div class="paranum"><a name="p27.p">27.p/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0067-1.TXT">AI05-0067-1</A></I>} 
<B>Correction:</B> Changed &ldquo;built in place&rdquo; to Dynamic Semantics 
and centralized the rules here. This eliminates the fiction that built 
in place is just a combination of a permission and a requirement; it 
clearly has noticeable semantic effects. This wording change is not intended 
to change the semantics of any correct Ada program.&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-6-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
