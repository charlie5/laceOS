<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Tagged Types and Type Extensions</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.WideHanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.WideHanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-8-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>3.9 Tagged Types and Type Extensions</H1>
<div class="paranum"><a name="p1">1</a></div>
<div class="Normal">[<A NAME="I2230"></A> <A NAME="I2231"></A><A NAME="I2232"></A><A NAME="I2233"></A><A NAME="I2234"></A>Tagged 
types and type extensions support object-oriented programming, based 
on inheritance with extension and run-time polymorphism via <I>dispatching 
operations</I>. <A NAME="I2235"></A><A NAME="I2236"></A><A NAME="I2237"></A>]</div>

<H4 Class="centered">Language Design Principles</H4>
<div class="paranum"><a name="p1.a">1.a/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The intended implementation model is for the static portion of a tag 
to be represented as a pointer to a statically allocated and link-time 
initialized type descriptor. The type descriptor contains the address 
of the code for each primitive operation of the type. It probably also 
contains other information, such as might make membership tests convenient 
and efficient. Tags for nested type extensions must also have a dynamic 
part that identifies the particular elaboration of the type.</div>
<div class="paranum"><a name="p1.b">1.b</a></div>
<div class="Annotations">The primitive operations of a tagged type are 
known at its first freezing point; the type descriptor is laid out at 
that point. It contains linker symbols for each primitive operation; 
the linker fills in the actual addresses.</div>
<div class="paranum"><a name="p1.b.1">1.b.1/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Primitive operations of type extensions that are declared at a level 
deeper than the level of the ultimate ancestor from which they are derived 
can be represented by wrappers that use the dynamic part of the tag to 
call the actual primitive operation. The dynamic part would generally 
be some way to represent the static link or display necessary for making 
a nested call. One implementation strategy would be to store that information 
in the extension part of such nested type extensions, and use the dynamic 
part of the tag to point at it. (That way, the &ldquo;dynamic&rdquo; 
part of the tag could be static, at the cost of indirect access.)</div>
<div class="paranum"><a name="p1.b.2">1.b.2/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
If the tagged type is descended from any interface types, it also will 
need to include &ldquo;subtags&rdquo; (one for each interface) that describe 
the mapping of the primitive operations of the interface to the primitives 
of the type. These subtags could directly reference the primitive operations 
(for faster performance), or simply provide the tag &ldquo;slot&rdquo; 
numbers for the primitive operations (for easier derivation). In either 
case, the subtags would be used for calls that dispatch through a class-wide 
type of the interface.</div>
<div class="paranum"><a name="p1.c">1.c</a></div>
<div class="Annotations">Other implementation models are possible.</div>
<div class="paranum"><a name="p1.d">1.d</a></div>
<div class="Annotations">The rules ensure that &ldquo;dangling dispatching&rdquo; 
is impossible; that is, when a dispatching call is made, there is always 
a body to execute. This is different from some other object-oriented 
languages, such as Smalltalk, where it is possible to get a run-time 
error from a missing method.</div>
<div class="paranum"><a name="p1.e">1.e/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Dispatching calls should be efficient, and should have a bounded worst-case 
execution time. This is important in a language intended for real-time 
applications. In the intended implementation model, a dispatching call 
involves calling indirect through the appropriate slot in the dispatch 
table. No complicated &quot;method lookup&quot; is involved although 
a call which is dispatching on an interface may require a lookup of the 
appropriate interface subtag.</div>
<div class="paranum"><a name="p1.f">1.f</a></div>
<div class="Annotations">The programmer should have the choice at each 
call site of a dispatching operation whether to do a dispatching call 
or a statically determined call (i.e. whether the body executed should 
be determined at run time or at compile time).</div>
<div class="paranum"><a name="p1.g">1.g</a></div>
<div class="Annotations">The same body should be executed for a call 
where the tag is statically determined to be T'Tag as for a dispatching 
call where the tag is found at run time to be T'Tag. This allows one 
to test a given tagged type with statically determined calls, with some 
confidence that run-time dispatching will produce the same behavior.</div>
<div class="paranum"><a name="p1.h">1.h</a></div>
<div class="Annotations">All views of a type should share the same type 
descriptor and the same tag.</div>
<div class="paranum"><a name="p1.i">1.i</a></div>
<div class="Annotations">The visibility rules determine what is legal 
at compile time; they have nothing to do with what bodies can be executed 
at run time. Thus, it is possible to dispatch to a subprogram whose declaration 
is not visible at the call site. In fact, this is one of the primary 
facts that gives object-oriented programming its power. The subprogram 
that ends up being dispatched to by a given call might even be designed 
long after the call site has been coded and compiled.</div>
<div class="paranum"><a name="p1.j">1.j</a></div>
<div class="Annotations">Given that Ada has overloading, determining 
whether a given subprogram overrides another is based both on the names 
and the type profiles of the operations.</div>
<div class="paranum"><a name="p1.k">1.k/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
When a type extension is declared, if there is any place within its immediate 
scope where a certain subprogram of the parent or progenitor is visible, 
then a matching subprogram should override. If there is no such place, 
then a matching subprogram should be totally unrelated, and occupy a 
different slot in the type descriptor. This is important to preserve 
the privacy of private parts; when an operation declared in a private 
part is inherited, the inherited version can be overridden only in that 
private part, in the package body, and in any children of the package.</div>
<div class="paranum"><a name="p1.l">1.l</a></div>
<div class="Annotations">If an implementation shares code for instances 
of generic bodies, it should be allowed to share type descriptors of 
tagged types declared in the generic body, so long as they are not extensions 
of types declared in the specification of the generic unit.&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p2">2/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<A NAME="I2238"></A>A record type or private type that has the reserved 
word <B>tagged</B> in its declaration is called a <I>tagged</I> type. 
In addition, an interface type is a tagged type, as is a task or protected 
type derived from an interface (see <A HREF="AA-3-9-4.html">3.9.4</A>). 
[When deriving from a tagged type, as for any derived type, additional 
primitive subprograms may be defined, and inherited primitive subprograms 
may be overridden.] <A NAME="I2239"></A><A NAME="I2240"></A>The derived 
type is called an <I>extension</I> of its ancestor types, or simply a 
<I>type extension</I>.</div>
<div class="paranum"><a name="p2.1">2.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<A NAME="I2241"></A><A NAME="I2242"></A><A NAME="I2243"></A>Every type 
extension is also a tagged type, and is a <I>record extension</I> or 
a <I>private extension</I> of some other tagged type, or a noninterface 
synchronized tagged type (see <A HREF="AA-3-9-4.html">3.9.4</A>). A record 
extension is defined by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
with a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
(see <A HREF="AA-3-9-1.html">3.9.1</A>)[, which may include the definition 
of additional components]. A private extension, which is a partial view 
of a record extension or of a synchronized tagged type, can be declared 
in the visible part of a package (see <A HREF="AA-7-3.html">7.3</A>) 
or in a generic formal part (see <A HREF="AA-12-5-1.html">12.5.1</A>). 
</div>
<div class="paranum"><a name="p2.a">2.a</a></div>
<div class="Annotations"><B>Glossary entry:&nbsp;</B>The objects of a tagged 
type have a run-time type tag, which indicates the specific type with 
which the object was originally created. An operand of a class-wide tagged 
type can be used in a dispatching call; the tag indicates which subprogram 
body to invoke. Nondispatching calls, in which the subprogram body to 
invoke is determined at compile time, are also allowed. Tagged types 
may be extended with additional components.</div>
<div class="paranum"><a name="p2.b">2.b/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-20218.TXT">AI95-00218-03</A></I>} 
If a tagged type is declared other than in a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0191">package_specification</A></SPAN>, 
it is impossible to add new primitive subprograms for that type, although 
it can inherit primitive subprograms, and those can be overridden. If 
the user incorrectly thinks a certain subprogram is primitive when it 
is not, and tries to call it with a dispatching call, an error message 
will be given at the call site. Similarly, by using an <SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0195">overriding_indicator</A></SPAN> 
(see <A HREF="AA-6-1.html">6.1</A>), the user can declare that a subprogram 
is intended to be overriding, and get an error message when they made 
a mistake. The use of <SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0195">overriding_indicator</A></SPAN>s 
is highly recommended in new code that does not need to be compatible 
with Ada 95.</div>
<div class="paranum"><a name="p2.c">2.c/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
</div>
<div class="paranum"><a name="p3">3</a></div>
<div class="Normal"><A NAME="I2244"></A>An object of a tagged type has 
an associated (run-time) <I>tag</I> that identifies the specific tagged 
type used to create the object originally. [ The tag of an operand of 
a class-wide tagged type <I>T</I>'Class controls which subprogram body 
is to be executed when a primitive subprogram of type <I>T</I> is applied 
to the operand (see <A HREF="AA-3-9-2.html">3.9.2</A>); <A NAME="I2245"></A>using 
a tag to control which body to execute is called <I>dispatching</I>.] 
<A NAME="I2246"></A><A NAME="I2247"></A><A NAME="I2248"></A><A NAME="I2249"></A></div>
<div class="paranum"><a name="p4">4/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
The tag of a specific tagged type identifies the <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
of the type, and for a type extension, is sufficient to uniquely identify 
the type among all descendants of the same ancestor. If a declaration 
for a tagged type occurs within a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0273">generic_package_declaration</A></SPAN>, 
then the corresponding type declarations in distinct instances of the 
generic package are associated with distinct tags. For a tagged type 
that is local to a generic package body and with all of its ancestors 
(if any) also local to the generic body, the language does not specify 
whether repeated instantiations of the generic body result in distinct 
tags.<A NAME="I2250"></A>&nbsp;</div>
<div class="paranum"><a name="p4.a">4.a/2</a></div>
<div class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
</div>
<div class="paranum"><a name="p4.a.1">4.a.1/2</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
In most cases, a tag need only identify a particular tagged type declaration, 
and can therefore be a simple link-time-known address. However, for tag 
checks (see <A HREF="AA-3-9-2.html">3.9.2</A>) it is essential that each 
descendant (that currently exists) of a given type have a unique tag. 
Hence, for types declared in shared generic bodies where an ancestor 
comes from outside the generic, or for types declared at a deeper level 
than an ancestor, the tag needs to be augmented with some kind of dynamic 
descriptor (which may be a static link, global display, instance descriptor 
pointer, or combination). This implies that type Tag may need to be two 
words, the second of which is normally null, but in these identified 
special cases needs to include a static link or equivalent. Within an 
object of one of these types with a two-word tag, the two parts of the 
tag would typically be separated, one part as the first word of the object, 
the second placed in the first extension part that corresponds to a type 
declared more nested than its parent or declared in a shared generic 
body when the parent is declared outside. Alternatively, by using an 
extra level of indirection, the type Tag could remain a single-word.</div>
<div class="paranum"><a name="p4.b">4.b/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
For types that are not type extensions (even for ones declared in nested 
scopes), we do not require that repeated elaborations of the same <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
correspond to distinct tags. This was done so that Ada 2005 implementations 
of tagged types could maintain representation compatibility with Ada 
95 implementations. Only type extensions that were not allowed in Ada 
95 require additional information with the tag.&nbsp;</div>
<div class="paranum"><a name="p4.c">4.c/2</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
The wording &ldquo;is sufficient to uniquely identify the type among 
all descendants of the same ancestor&rdquo; only applies to types that 
currently exist. It is not necessary to distinguish between descendants 
that currently exist, and descendants of the same type that no longer 
exist. For instance, the address of the stack frame of the subprogram 
that created the tag is sufficient to meet the requirements of this rule, 
even though it is possible, after the subprogram returns, that a later 
call of the subprogram could have the same stack frame and thus have 
an identical tag.&nbsp;</div>
<div class="paranum"><a name="p5">5</a></div>
<div class="Normal" style="margin-bottom: 0.4em">The following language-defined 
library package exists:&nbsp;</div>
<div class="paranum"><a name="p6">6/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00362.TXT">AI95-00362-01</A></I>} 
<A NAME="I2251"></A><B>package</B>&nbsp;Ada.Tags&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborate(Tags);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I2252"></A>Tag&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Tag);</div>
<div class="paranum"><a name="p6.1">6.1/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2253"></A>No_Tag&nbsp;:&nbsp;<B>constant</B>&nbsp;Tag;</div>
<div class="paranum"><a name="p7">7/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2254"></A>Expanded_Name(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2255"></A>Wide_Expanded_Name(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Wide_String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2256"></A>Wide_Wide_Expanded_Name(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Wide_Wide_String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2257"></A>External_Tag(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2258"></A>Internal_Tag(External&nbsp;:&nbsp;String)&nbsp;<B>return</B>&nbsp;Tag;</div>
<div class="paranum"><a name="p7.1">7.1/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2259"></A>Descendant_Tag(External&nbsp;:&nbsp;String;&nbsp;Ancestor&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2260"></A>Is_Descendant_At_Same_Level(Descendant,&nbsp;Ancestor&nbsp;:&nbsp;Tag)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="paranum"><a name="p7.2">7.2/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2261"></A>Parent_Tag&nbsp;(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Tag;</div>
<div class="paranum"><a name="p7.3">7.3/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I2262"></A>Tag_Array&nbsp;<B>is&nbsp;array</B>&nbsp;(Positive&nbsp;<B>range</B>&nbsp;&lt;&gt;)&nbsp;<B>of</B>&nbsp;Tag;</div>
<div class="paranum"><a name="p7.4">7.4/2</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2263"></A>Interface_Ancestor_Tags&nbsp;(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Tag_Array;</div>
<div class="paranum"><a name="p7.5">7.5/3</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0173-1.TXT">AI05-0173-1</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2264"></A>Is_Abstract&nbsp;(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="paranum"><a name="p8">8</a></div>
<div class="Examples">&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2265"></A>Tag_Error&nbsp;:&nbsp;<B>exception</B>;</div>
<div class="paranum"><a name="p9">9</a></div>
<div class="Examples"><B>private</B><BR>
&nbsp;&nbsp;&nbsp;...&nbsp;--&nbsp;<SPAN Class="roman"><I>not&nbsp;specified&nbsp;by&nbsp;the&nbsp;language</I></SPAN><BR>
<B>end</B>&nbsp;Ada.Tags;</div>
<div class="paranum"><a name="p9.a">9.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Tag is a nonlimited, definite 
subtype, because it needs the equality operators, so that tag checking 
makes sense. Also, equality, assignment, and object declaration are all 
useful capabilities for this subtype.</div>
<div class="paranum"><a name="p9.b">9.b</a></div>
<div class="Annotations">For an object X and a type T, &ldquo;X'Tag = 
T'Tag&rdquo; is not needed, because a membership test can be used. However, 
comparing the tags of two objects cannot be done via membership. This 
is one reason to allow equality for type Tag.&nbsp;</div>
<div class="paranum"><a name="p9.1">9.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
No_Tag is the default initial value of type Tag.&nbsp;</div>
<div class="paranum"><a name="p9.c">9.c/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
This is similar to the requirement that all access values be initialized 
to <B>null</B>.&nbsp;</div>
<div class="paranum"><a name="p10">10/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
The function Wide_Wide_Expanded_Name returns the full expanded name of 
the first subtype of the specific type identified by the tag, in upper 
case, starting with a root library unit. The result is implementation 
defined if the type is declared within an unnamed <SPAN Class="swiss"><A HREF="AA-5-6.html#S0160">block_statement</A></SPAN>. 
</div>
<div class="paranum"><a name="p10.a">10.a</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>This name, as well as each 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> of 
it, does not denote a <SPAN Class="swiss"><A HREF="AA-8-5.html#S0199">renaming_declaration</A></SPAN>. 
</div>
<div class="paranum"><a name="p10.b">10.b/2</a></div>
<div class="Annotations"><B>Implementation defined:&nbsp;</B>The result of 
Tags.Wide_Wide_Expanded_Name for types declared within an unnamed <SPAN Class="swiss"><A HREF="AA-5-6.html#S0160">block_statement</A></SPAN>.</div>
<div class="paranum"><a name="p10.1">10.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
The function Expanded_Name (respectively, Wide_Expanded_Name) returns 
the same sequence of graphic characters as that defined for Wide_Wide_Expanded_Name, 
if all the graphic characters are defined in Character (respectively, 
Wide_Character); otherwise, the sequence of characters is implementation 
defined, but no shorter than that returned by Wide_Wide_Expanded_Name 
for the same value of the argument.&nbsp;</div>
<div class="paranum"><a name="p10.c">10.c/2</a></div>
<div class="Annotations"><B>Implementation defined:&nbsp;</B>The sequence 
of characters of the value returned by Tags.Expanded_Name (respectively, 
Tags.Wide_Expanded_Name) when some of the graphic characters of Tags.Wide_Wide_Expanded_Name 
are not defined in Character (respectively, Wide_Character).</div>
<div class="paranum"><a name="p11">11</a></div>
<div class="Normal">The function External_Tag returns a string to be 
used in an external representation for the given tag. The call External_Tag(S'Tag) 
is equivalent to the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
S'External_Tag (see <A HREF="AA-13-3.html">13.3</A>).&nbsp;</div>
<div class="paranum"><a name="p11.a">11.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>It might seem redundant to provide 
both the function External_Tag and the attribute External_Tag. The function 
is needed because the attribute can't be applied to values of type Tag. 
The attribute is needed so that it can be specified via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0310">attribute_definition_clause</A></SPAN>. 
</div>
<div class="paranum"><a name="p11.1">11.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00417.TXT">AI95-00417-01</A></I>} 
The string returned by the functions Expanded_Name, Wide_Expanded_Name, 
Wide_Wide_Expanded_Name, and External_Tag has lower bound 1.</div>
<div class="paranum"><a name="p12">12/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
The function Internal_Tag returns a tag that corresponds to the given 
external tag, or raises Tag_Error if the given string is not the external 
tag for any specific type of the partition. Tag_Error is also raised 
if the specific type identified is a library-level type whose tag has 
not yet been created (see <A HREF="AA-13-14.html">13.14</A>).</div>
<div class="paranum"><a name="p12.a">12.a/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
The check for uncreated library-level types prevents a reference to the 
type before execution reaches the freezing point of the type. This is 
important so that T'Class'Input or an instance of Tags.Generic_Dispatching_Constructor 
do not try to create an object of a type that hasn't been frozen (which 
might not have yet elaborated its constraints). We don't require this 
behavior for non-library-level types as the tag can be created multiple 
times and possibly multiple copies can exist at the same time, making 
the check complex.&nbsp;</div>
<div class="paranum"><a name="p12.1">12.1/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0113-1.TXT">AI05-0113-1</A></I>} 
The function Descendant_Tag returns the (internal) tag for the type that 
corresponds to the given external tag and is both a descendant of the 
type identified by the Ancestor tag and has the same accessibility level 
as the identified ancestor. Tag_Error is raised if External is not the 
external tag for such a type. Tag_Error is also raised if the specific 
type identified is a library-level type whose tag has not yet been created, 
or if the given external tag identifies more than one type that has the 
appropriate Ancestor and accessibility level.</div>
<div class="paranum"><a name="p12.b">12.b/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Descendant_Tag is used by T'Class'Input 
to identify the type identified by an external tag. Because there can 
be multiple elaborations of a given type declaration, Internal_Tag does 
not have enough information to choose a unique such type. Descendant_Tag 
does not return the tag for types declared at deeper accessibility levels 
than the ancestor because there could be ambiguity in the presence of 
recursion or multiple tasks. Descendant_Tag can be used in constructing 
a user-defined replacement for T'Class'Input.</div>
<div class="paranum"><a name="p12.b.1">12.b.1/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0113-1.TXT">AI05-0113-1</A></I>} 
Rules for specifying external tags will usually prevent an external tag 
from identifying more than one type. However, an external tag can identify 
multiple types if a generic body contains a derivation of a tagged type 
declared outside of the generic, and there are multiple instances at 
the same accessibility level as the type. (The Standard allows default 
external tags to not be unique in this case.)&nbsp;</div>
<div class="paranum"><a name="p12.2">12.2/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
The function Is_Descendant_At_Same_Level returns True if the Descendant 
tag identifies a type that is both a descendant of the type identified 
by Ancestor and at the same accessibility level. If not, it returns False.</div>
<div class="paranum"><a name="p12.c">12.c/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Is_Descendant_At_Same_Level (or 
something similar to it) is used by T'Class'Output to determine whether 
the item being written is at the same accessibility level as T. It may 
be used to determine prior to using T'Class'Output whether Tag_Error 
will be raised, and also can be used in constructing a user-defined replacement 
for T'Class'Output.&nbsp;</div>
<div class="paranum"><a name="p12.3">12.3/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0115-1.TXT">AI05-0115-1</A></I>} 
For the purposes of the dynamic semantics of functions Descendant_Tag 
and Is_Descendant_At_Same_Level, a tagged type T2 is a <I>descendant</I> 
of a type T1 if it is the same as T1, or if its parent type or one of 
its progenitor types is a descendant of type T1 by this rule[, even if 
at the point of the declaration of T2, one of the derivations in the 
chain is not visible].<A NAME="I2266"></A></div>
<div class="paranum"><a name="p12.c.1">12.c.1/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>In other contexts, &ldquo;descendant&rdquo; 
is dependent on visibility, and the particular view a derived type has 
of its parent type. See <A HREF="AA-7-3-1.html">7.3.1</A>.&nbsp;</div>
<div class="paranum"><a name="p12.4">12.4/4</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0056-1.TXT">AI12-0056-1</A></I>} 
The function Parent_Tag returns the tag of the parent type of the type 
whose tag is T. If the type does not have a parent type (that is, it 
was not <span class="insert4">defined</span><span class="delete4">&nbsp;declared</span> 
by a <span class="insert4"><SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN></span><span class="delete4">&nbsp;derived_type_declaration</span>), 
then No_Tag is returned.</div>
<div class="paranum"><a name="p12.d">12.d/4</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
The parent type is always the parent of the full type; a private extension 
appears to define a parent type, but it does not (only the various forms 
of derivation do that). As this is a run-time operation, ignoring <span class="insert4">privacy</span><span class="delete4">&nbsp;privateness</span> 
is OK.&nbsp;</div>
<div class="paranum"><a name="p12.5">12.5/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
The function Interface_Ancestor_Tags returns an array containing the 
tag of each interface ancestor type of the type whose tag is T, other 
than T itself. The lower bound of the returned array is 1, and the order 
of the returned tags is unspecified. Each tag appears in the result exactly 
once.[ If the type whose tag is T has no interface ancestors, a null 
array is returned.]<A NAME="I2267"></A></div>
<div class="paranum"><a name="p12.e">12.e/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The result of Interface_Ancestor_Tags 
includes the tag of the parent type, if the parent is an interface.</div>
<div class="paranum"><a name="p12.f">12.f/2</a></div>
<div class="Annotations">Indirect interface ancestors are included in 
the result of Interface_Ancestor_Tags. That's because where an interface 
appears in the derivation tree has no effect on the semantics of the 
type; the only interesting property is whether the type has an interface 
as an ancestor.&nbsp;</div>
<div class="paranum"><a name="p12.6">12.6/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0173-1.TXT">AI05-0173-1</A></I>} 
The function Is_Abstract returns True if the type whose tag is T is abstract, 
and False otherwise.</div>
<div class="paranum"><a name="p13">13</a></div>
<div class="Normal">For every subtype S of a tagged type <I>T</I> (specific 
or class-wide), the following attributes are defined:&nbsp;</div>
<div class="paranum"><a name="p14">14</a></div>
<div class="WideHanging-Term">S'Class</div><div class="WideHanging-Body">
<A NAME="I2268"></A><A NAME="I2269"></A>S'Class denotes a subtype of 
the class-wide type (called <I>T</I>'Class in this International Standard) 
for the class rooted at <I>T</I> (or if S already denotes a class-wide 
subtype, then S'Class is the same as S).</div>
<div class="paranum"><a name="p15">15</a></div>
<div class="WideHanging-Body"><A NAME="I2270"></A><A NAME="I2271"></A>S'Class 
is unconstrained. However, if S is constrained, then the values of S'Class 
are only those that when converted to the type <I>T</I> belong to S. 
</div>
<div class="paranum"><a name="p15.a">15.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This attribute is defined 
for both specific and class-wide subtypes. The definition is such that 
S'Class'Class is the same as S'Class.</div>
<div class="paranum"><a name="p15.b">15.b</a></div>
<div class="Annotations">Note that if S is constrained, S'Class is only 
partially constrained, since there might be additional discriminants 
added in descendants of <I>T</I> which are not constrained.&nbsp;</div>
<div class="paranum"><a name="p15.c">15.c/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
The Class attribute is not defined for untagged subtypes (except for 
incomplete types and private types whose full view is tagged &mdash; 
see <A HREF="AA-J-11.html">J.11</A> and <A HREF="AA-7-3-1.html">7.3.1</A>) 
so as to preclude implicit conversion in the absence of run-time type 
information. If it were defined for untagged subtypes, it would correspond 
to the concept of universal types provided for the predefined numeric 
classes.&nbsp;</div>
<div class="paranum"><a name="p16">16</a></div>
<div class="WideHanging-Term">S'Tag</div><div class="WideHanging-Body">
<A NAME="I2272"></A><A NAME="I2273"></A>S'Tag denotes the tag of the 
type <I>T</I> (or if <I>T</I> is class-wide, the tag of the root type 
of the corresponding class). The value of this attribute is of type Tag. 
</div>
<div class="paranum"><a name="p16.a">16.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>S'Class'Tag equals S'Tag, to 
avoid generic contract model problems when S'Class is the actual type 
associated with a generic formal derived type.</div>
<div class="paranum"><a name="p17">17</a></div>
<div class="Normal">Given a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
X that is of a class-wide tagged type [(after any implicit dereference)], 
the following attribute is defined:&nbsp;</div>
<div class="paranum"><a name="p18">18</a></div>
<div class="WideHanging-Term">X'Tag</div><div class="WideHanging-Body">
<A NAME="I2274"></A><A NAME="I2275"></A>X'Tag denotes the tag of X. The 
value of this attribute is of type Tag.&nbsp;</div>
<div class="paranum"><a name="p18.a">18.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>X'Tag is not defined if X is 
of a specific type. This is primarily to avoid confusion that might result 
about whether the Tag attribute should reflect the tag of the type of 
X, or the tag of X. No such confusion is possible if X is of a class-wide 
type.&nbsp;</div>
<div class="paranum"><a name="p18.1">18.1/2</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
The following language-defined generic function exists:</div>
<div class="paranum"><a name="p18.2">18.2/3</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<A NAME="I2276"></A><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;(&lt;&gt;)&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;limited&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parameters&nbsp;(&lt;&gt;)&nbsp;<B>is&nbsp;limited&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Constructor&nbsp;(Params&nbsp;:&nbsp;<B>not&nbsp;null&nbsp;access</B>&nbsp;Parameters)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;T&nbsp;<B>is&nbsp;abstract</B>;<BR>
<B>function</B>&nbsp;Ada.Tags.Generic_Dispatching_Constructor<BR>
&nbsp;&nbsp;&nbsp;(The_Tag&nbsp;:&nbsp;Tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Params&nbsp;&nbsp;:&nbsp;<B>not&nbsp;null&nbsp;access</B>&nbsp;Parameters)&nbsp;<B>return</B>&nbsp;T'Class<BR>
&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Convention&nbsp;=&gt;&nbsp;Intrinsic;<BR>
<B>pragma</B>&nbsp;Preelaborate(Generic_Dispatching_Constructor);</div>
<div class="paranum"><a name="p18.3">18.3/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
Tags.Generic_Dispatching_Constructor provides a mechanism to create an 
object of an appropriate type from just a tag value. The function Constructor 
is expected to create the object given a reference to an object of type 
Parameters.</div>
<div class="paranum"><a name="p18.b">18.b/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>This specification is designed 
to make it easy to create dispatching constructors for streams; in particular, 
this can be used to construct overridings for T'Class'Input.</div>
<div class="paranum"><a name="p18.c">18.c/2</a></div>
<div class="Annotations">Note that any tagged type will match T (see 
<A HREF="AA-12-5-1.html">12.5.1</A>).&nbsp;</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p19">19</a></div>
<div class="Normal" style="margin-bottom: 0.4em">The tag associated 
with an object of a tagged type is determined as follows:&nbsp;</div>
<div class="paranum"><a name="p20">20</a></div>
<div class="Bulleted"><A NAME="I2277"></A>The tag of a stand-alone object, 
a component, or an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN> 
of a specific tagged type <I>T</I> identifies <I>T</I>.&nbsp;</div>
<div class="paranum"><a name="p20.a">20.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The tag of a formal parameter 
of type <I>T</I> is not necessarily the tag of <I>T</I>, if, for example, 
the actual was a type conversion.&nbsp;</div>
<div class="paranum"><a name="p21">21</a></div>
<div class="Bulleted"><A NAME="I2278"></A>The tag of an object created 
by an allocator for an access type with a specific designated tagged 
type <I>T</I>, identifies <I>T</I>.&nbsp;</div>
<div class="paranum"><a name="p21.a">21.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The tag of an object designated 
by a value of such an access type might not be <I>T</I>, if, for example, 
the access value is the result of a type conversion.</div>
<div class="paranum"><a name="p22">22</a></div>
<div class="Bulleted"><A NAME="I2279"></A>The tag of an object of a class-wide 
tagged type is that of its initialization expression.&nbsp;</div>
<div class="paranum"><a name="p22.a">22.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The tag of an object (even 
a class-wide one) cannot be changed after it is initialized, since a 
&ldquo;class-wide&rdquo; <SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN> 
raises Constraint_Error if the tags don't match, and a &ldquo;specific&rdquo; 
<SPAN Class="swiss"><A HREF="AA-5-2.html#S0152">assignment_statement</A></SPAN> 
does not affect the tag.&nbsp;</div>
<div class="paranum"><a name="p23">23</a></div>
<div class="Bulleted"><A NAME="I2280"></A>The tag of the result returned 
by a function whose result type is a specific tagged type <I>T</I> identifies 
<I>T</I>.&nbsp;</div>
<div class="paranum"><a name="p23.a">23.a/2</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
For a limited tagged type, the return object is &ldquo;built in place&rdquo; 
in the ultimate result object with the appropriate tag. For a nonlimited 
type, a new anonymous object with the appropriate tag is created as part 
of the function return. See <A HREF="AA-6-5.html">6.5</A>, &ldquo;<A HREF="AA-6-5.html">Return 
Statements</A>&rdquo;.&nbsp;</div>
<div class="paranum"><a name="p24">24/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<A NAME="I2281"></A>The tag of the result returned by a function with 
a class-wide result type is that of the return object.&nbsp;</div>
<div class="paranum"><a name="p25">25</a></div>
<div class="Normal"><A NAME="I2282"></A>The tag is preserved by type 
conversion and by parameter passing. The tag of a value is the tag of 
the associated object (see <A HREF="AA-6-2.html">6.2</A>).</div>
<div class="paranum"><a name="p25.1">25.1/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0092-1.TXT">AI05-0092-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
Tag_Error is raised by a call of Descendant_Tag, Expanded_Name, External_Tag, 
Interface_Ancestor_Tags, Is_Abstract, Is_Descendant_At_Same_Level, Parent_Tag, 
Wide_Expanded_Name, or Wide_Wide_Expanded_Name if any tag passed is No_Tag.</div>
<div class="paranum"><a name="p25.2">25.2/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
An instance of Tags.Generic_Dispatching_Constructor raises Tag_Error 
if The_Tag does not represent a concrete descendant of T or if the innermost 
master (see <A HREF="AA-7-6-1.html">7.6.1</A>) of this descendant is 
not also a master of the instance. Otherwise, it dispatches to the primitive 
function denoted by the formal Constructor for the type identified by 
The_Tag, passing Params, and returns the result. Any exception raised 
by the function is propagated.</div>
<div class="paranum"><a name="p25.a">25.a/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The tag check checks both 
that The_Tag is in T'Class, and that it is not abstract. These checks 
are similar to the ones required by streams for T'Class'Input (see <A HREF="AA-13-13-2.html">13.13.2</A>). 
In addition, there is a check that the tag identifies a type declared 
on the current dynamic call chain, and not a more nested type or a type 
declared by another task. This check is not necessary for streams, because 
the stream attributes are declared at the same dynamic level as the type 
used.&nbsp;</div>

<H4 Class="centered">Erroneous Execution</H4>
<div class="paranum"><a name="p25.3">25.3/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<A NAME="I2283"></A>If an internal tag provided to an instance of Tags.Generic_Dispatching_Constructor 
or to any subprogram declared in package Tags identifies either a type 
that is not library-level and whose tag has not been created (see <A HREF="AA-13-14.html">13.14</A>), 
or a type that does not exist in the partition at the time of the call, 
then execution is erroneous.</div>
<div class="paranum"><a name="p25.b">25.b/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>One reason that a type 
might not exist in the partition is that the tag refers to a type whose 
declaration was elaborated as part of an execution of a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0177">subprogram_body</A></SPAN> 
which has been left (see <A HREF="AA-7-6-1.html">7.6.1</A>).</div>
<div class="paranum"><a name="p25.c">25.c/2</a></div>
<div class="Annotations">We exclude tags of library-level types from 
the current execution of the partition, because misuse of such tags should 
always be detected. T'Tag freezes the type (and thus creates the tag), 
and Internal_Tag and Descendant_Tag cannot return the tag of a library-level 
type that has not been created. All ancestors of a tagged type must be 
frozen no later than the (full) declaration of a type that uses them, 
so Parent_Tag and Interface_Ancestor_Tags cannot return a tag that has 
not been created. Finally, library-level types never cease to exist while 
the partition is executing. Thus, if the tag comes from a library-level 
type, there cannot be erroneous execution (the use of Descendant_Tag 
rather than Internal_Tag can help ensure that the tag is of a library-level 
type). This is also similar to the rules for T'Class'Input (see <A HREF="AA-13-13-2.html">13.13.2</A>). 
</div>
<div class="paranum"><a name="p25.d">25.d/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
Ada 95 allowed Tag_Error in this case, or expected the functions to work. 
This worked because most implementations used tags constructed at link-time, 
and each elaboration of the same <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN> 
produced the same tag. However, Ada 2005 requires at least part of the 
tags to be dynamically constructed for a type derived from a type at 
a shallower level. For dynamically constructed tags, detecting the error 
can be expensive and unreliable. To see this, consider a program containing 
two tasks. Task A creates a nested tagged type, passes the tag to task 
B (which saves it), and then terminates. The nested tag (if dynamic) 
probably will need to refer in some way to the stack frame for task A. 
If task B later tries to use the tag created by task A, the tag's reference 
to the stack frame of A probably is a dangling pointer. Avoiding this 
would require some sort of protected tag manager, which would be a bottleneck 
in a program's performance. Moreover, we'd still have a race condition; 
if task A terminated after the tag check, but before the tag was used, 
we'd still have a problem. That means that all of these operations would 
have to be serialized. That could be a significant performance drain, 
whether or not nested tagged types are ever used. Therefore, we allow 
execution to become erroneous as we do for other dangling pointers. If 
the implementation can detect the error, we recommend that Tag_Error 
be raised.&nbsp;</div>

<H4 Class="centered">Implementation Permissions</H4>
<div class="paranum"><a name="p26">26/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
The implementation of Internal_Tag and Descendant_Tag may raise Tag_Error 
if no specific type corresponding to the string External passed as a 
parameter exists in the partition at the time the function is called, 
or if there is no such type whose innermost master is a master of the 
point of the function call.&nbsp;</div>
<div class="paranum"><a name="p26.a">26.a/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
Locking would be required to ensure that the mapping of strings to tags 
never returned tags of types which no longer exist, because types can 
cease to exist (because they belong to another task, as described above) 
during the execution of these operations. Moreover, even if these functions 
did use locking, that would not prevent the type from ceasing to exist 
at the instant that the function returned. Thus, we do not require the 
overhead of locking; hence the word &ldquo;may&rdquo; in this rule.&nbsp;</div>

<H4 Class="centered">Implementation Advice</H4>
<div class="paranum"><a name="p26.1">26.1/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0113-1.TXT">AI05-0113-1</A></I>} 
Internal_Tag should return the tag of a type, if one exists, whose innermost 
master is a master of the point of the function call.&nbsp;</div>
<div class="paranum"><a name="p26.b">26.b/3</a></div>
<div class="Annotations"><B>Implementation Advice:&nbsp;</B>Tags.Internal_Tag 
should return the tag of a type, if one exists, whose innermost master 
is a master of the point of the function call..</div>
<div class="paranum"><a name="p26.c">26.c/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
It's not helpful if Internal_Tag returns the tag of some type in another 
task when one is available in the task that made the call. We don't require 
this behavior (because it requires the same implementation techniques 
we decided not to insist on previously), but encourage it.&nbsp;</div>
<div class="paranum"><a name="p26.d">26.d/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0113-1.TXT">AI05-0113-1</A></I>} 
There is no Advice for the result of Internal_Tag if no such type exists. 
In most cases, the Implementation Permission can be used to raise Tag_Error, 
but some other tag can be returned as well.&nbsp;</div>
<div class="NotesHeader">NOTES</div>
<div class="paranum"><a name="p27">27</a></div>
<div class="Notes">70&nbsp;&nbsp;A type declared with the reserved word 
<B>tagged</B> should normally be declared in a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0191">package_specification</A></SPAN>, 
so that new primitive subprograms can be declared for it.</div>
<div class="paranum"><a name="p28">28</a></div>
<div class="Notes">71&nbsp;&nbsp;Once an object has been created, its 
tag never changes.</div>
<div class="paranum"><a name="p29">29</a></div>
<div class="Notes">72&nbsp;&nbsp;Class-wide types are defined to have 
unknown discriminants (see <A HREF="AA-3-7.html">3.7</A>). This means 
that objects of a class-wide type have to be explicitly initialized (whether 
created by an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
or an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>), 
and that <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>s 
have to be explicitly qualified with a specific type when their expected 
type is class-wide.</div>
<div class="paranum"><a name="p30">30/2</a></div>
<div class="Notes">73&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
The capability provided by Tags.Generic_Dispatching_Constructor is sometimes 
known as a <I>factory</I>.<A NAME="I2284"></A><A NAME="I2285"></A>&nbsp;</div>

<H4 Class="centered">Examples</H4>
<div class="paranum"><a name="p31">31</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><I>Examples of tagged 
record types:</I>&nbsp;</div>
<div class="paranum"><a name="p32">32</a></div>
<div class="Examples"><B>type</B>&nbsp;Point&nbsp;<B>is&nbsp;tagged</B><BR>
&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y&nbsp;:&nbsp;Real&nbsp;:=&nbsp;0.0;<BR>
&nbsp;&nbsp;<B>end&nbsp;record</B>;</div>
<div class="paranum"><a name="p33">33</a></div>
<div class="Examples"><B>type</B>&nbsp;Expression&nbsp;<B>is&nbsp;tagged&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Components&nbsp;will&nbsp;be&nbsp;added&nbsp;by&nbsp;each&nbsp;extension</I></SPAN></div>

<H4 Class="centered">Extensions to Ada 83</H4>
<div class="paranum"><a name="p33.a">33.a</a></div>
<div class="Annotations"><A NAME="I2286"></A>Tagged types are a new concept. 
</div>

<H4 Class="centered">Inconsistencies With Ada 95</H4>
<div class="paranum"><a name="p33.b">33.b/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<A NAME="I2287"></A><B>Amendment Correction:</B> Added wording specifying 
that Internal_Tag must raise Tag_Error if the tag of a library-level 
type has not yet been created. Ada 95 gave an Implementation Permission 
to do this; we require it to avoid erroneous execution when streaming 
in an object of a library-level type that has not yet been elaborated. 
This is technically inconsistent; a program that used Internal_Tag outside 
of streaming and used a compiler that didn't take advantage of the Implementation 
Permission would not have raised Tag_Error, and may have returned a useful 
tag. (If the tag was used in streaming, the program would have been erroneous.) 
Since such a program would not have been portable to a compiler that 
did take advantage of the Implementation Permission, this is not a significant 
inconsistency.</div>
<div class="paranum"><a name="p33.c">33.c/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00417.TXT">AI95-00417-01</A></I>} 
We now define the lower bound of the string returned from [[Wide_]Wide_]Expanded_Name 
and External_Name. This makes working with the returned string easier, 
and is consistent with many other string-returning functions in Ada. 
This is technically an inconsistency; if a program depended on some other 
lower bound for the string returned from one of these functions, it could 
fail when compiled with Ada 2005. Such code is not portable even between 
Ada 95 implementations, so it should be very rare.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<div class="paranum"><a name="p33.d">33.d/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
<A NAME="I2288"></A>Constant No_Tag, and functions Parent_Tag, Interface_Ancestor_Tags, 
Descendant_Tag, Is_Descendant_At_Same_Level, Wide_Expanded_Name, and 
Wide_Wide_Expanded_Name are added to Ada.Tags. If Ada.Tags is referenced 
in a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0196">use_clause</A></SPAN>, 
and an entity <I>E</I> with the same <SPAN Class="swiss"><A HREF="AA-3-1.html#S0022">defining_identifier</A></SPAN> 
as a new entity in Ada.Tags is defined in a package that is also referenced 
in a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0196">use_clause</A></SPAN>, 
the entity <I>E</I> may no longer be use-visible, resulting in errors. 
This should be rare and is easily fixed if it does occur.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum"><a name="p33.e">33.e/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00362.TXT">AI95-00362-01</A></I>} 
<A NAME="I2289"></A>Ada.Tags is now defined to be preelaborated.</div>
<div class="paranum"><a name="p33.f">33.f/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
Generic function Tags.Generic_Dispatching_Constructor is new.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p33.g">33.g/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
We talk about return objects rather than return expressions, as functions 
can return using an <SPAN Class="swiss"><A HREF="AA-6-5.html#S0186">extended_return_statement</A></SPAN>.</div>
<div class="paranum"><a name="p33.h">33.h/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
Added wording to define that tags for all descendants of a tagged type 
must be distinct. This is needed to ensure that more nested type extensions 
will work properly. The wording does not require implementation changes 
for types that were allowed in Ada 95.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2005</H4>
<div class="paranum"><a name="p33.i">33.i/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0113-1.TXT">AI05-0113-1</A></I>} 
<A NAME="I2290"></A><B>Correction:</B> Added wording specifying that 
Dependent_Tag must raise Tag_Error if there is more than one type which 
matches the requirements. If an implementation had returned a random 
tag of the matching types, a program may have worked properly. However, 
such a program would not be portable (another implementation may return 
a different tag) and the conditions that would cause the problem are 
unlikely (most likely, a tagged type extension declared in a generic 
body with multiple instances in the same scope).&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 2005</H4>
<div class="paranum"><a name="p33.j">33.j/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0173-1.TXT">AI05-0173-1</A></I>} 
<A NAME="I2291"></A>Function Is_Abstract is added to Ada.Tags. If Ada.Tags 
is referenced in a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0196">use_clause</A></SPAN>, 
and an entity <I>E</I> with the <SPAN Class="swiss"><A HREF="AA-3-1.html#S0022">defining_identifier</A></SPAN> 
Is_Abstract is defined in a package that is also referenced in a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0196">use_clause</A></SPAN>, 
the entity <I>E</I> may no longer be use-visible, resulting in errors. 
This should be rare and is easily fixed if it does occur.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p33.k">33.k/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0115-1.TXT">AI05-0115-1</A></I>} 
<B>Correction:</B> We explicitly define the meaning of &quot;descendant&quot; 
at runtime, so that it does not depend on visibility as does the usual 
meaning.&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-8-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
